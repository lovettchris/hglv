import Mathlib.Tactic.Basic
import Mathlib.Tactic.Cases
import Basics.FunctionDefinitions
namespace hglv
/-!
## Proofs by Mathematical Induction

The `induction'` tactic performs structural induction on an inductive type. _Structural induction_
simply means that the induction follows the structure of the inductive type. For natural numbers
constructed from `Nat.zero` and `Nat.succ`, structural induction corresponds to standard mathematical
induction: To prove `p n`, it suffices to prove `p 0` and `∀k, p k → p (k + 1)`. Equipped with `induction'`,
we can reason about the addition and multiplication operations we defined by recursion in
[Function Definitions](../Basics/FunctionDefinitions.lean.md). Addition is defined by recursion on its
second argument. We will prove two lemmas, `add_zero` and `add_succ`, that give us alternative equations
that recurse on the first argument. We start with `add_zero`:
-/
lemma add_zero (n : ℕ) :
add 0 n = n := by
  induction' n with n ih
  { rfl }
  { simp [add, ih] }
/-!
The first `{ }` encloses the base case `⊢ add 0 0 = 0`. The second block corresponds
to the induction step
```lean
n : N, ih : add 0 n = n ` add 0 (Nat.succ n) = (Nat.succ n)
```
The local variable `n` in the induction step should not be confused with the `n` in
the lemma statement. Like mathematicians, `induction’` tries to reuse variable
names that are no longer needed. The name `ih` for the induction hypothesis, in
the induction step, is also generated by the `induction’` tactic.

We can keep on proving lemmas by structural induction:
-/
lemma add_succ (m n : ℕ) :
  add (Nat.succ m) n = Nat.succ (add m n) := by
  induction' n with n ih
  { rfl }
  { simp [add, ih] }

lemma add_comm (m n : ℕ) :
  add m n = add n m := by
  induction' n with n ih
  { simp [add, add_zero] }
  { simp [add, add_succ, ih] }

lemma add_assoc (l m n : ℕ) :
  add (add l m) n = add l (add m n) := by
  induction' n with n ih
  { rfl }
  { simp [add, ih] }

/-!
Once we have proved that a binary operator is commutative and associative, it
is a good idea to let Lean’s automation, notably `cc`, know about this
using type classes.  See [Type Classes](../Basics/TypeClasses.lean.md).

The following example uses the `cc` tactic to reason up to associativity and commutativity of `add`:
-/
lemma mul_add (l m n : ℕ) :
mul l (add m n) = add (mul l m) (mul l n) := by
  induction' n with n ih
  { rfl }
  { simp [add, mul, ih]
    cc }
/-!
-- BUGBUG: 'cc' is still missing from mathlib...

Here are a few hints on how to carry out proofs by induction:

- It is usually beneficial to perform induction following the structure of the definition of one of
  the functions appearing in the goal. In particular, if a function is defined by recursion on its
  _n_ th argument, it usually makes sense to perform the induction on that argument.

- If the base case of an induction is difficult, this is often a sign that the wrong variable was
  chosen or that some lemmas should be proved first.

-/