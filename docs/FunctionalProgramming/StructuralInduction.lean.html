<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Structural Induction - The Hitchhiker’s Guide to Logical Verification</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../alectryon.css">
        <link rel="stylesheet" href="../pygments.css">
        <link rel="stylesheet" href="../custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../cover.html">Cover</a></li><li class="chapter-item affix "><a href="../preface.html">Preface</a></li><li class="chapter-item "><a href="../Basics/Definitions.lean.html"><strong aria-hidden="true">1.</strong> Definitions and Statements</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../Basics/TypesAndTerms.lean.html"><strong aria-hidden="true">1.1.</strong> Types and Terms</a></li><li class="chapter-item "><a href="../Basics/TypeDefinitions.lean.html"><strong aria-hidden="true">1.2.</strong> Type Definitions</a></li><li class="chapter-item "><a href="../Basics/FunctionDefinitions.lean.html"><strong aria-hidden="true">1.3.</strong> Function Definitions</a></li><li class="chapter-item "><a href="../Basics/TheoremStatements.lean.html"><strong aria-hidden="true">1.4.</strong> Theorem Statements</a></li><li class="chapter-item "><a href="../Basics/Summary.html"><strong aria-hidden="true">1.5.</strong> Summary of New Lean Constructs</a></li></ol></li><li class="chapter-item "><a href="../BackwardProofs.lean.html"><strong aria-hidden="true">2.</strong> Backward Proofs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../BackwardProofs/TacticMode.lean.html"><strong aria-hidden="true">2.1.</strong> Tactic Mode</a></li><li class="chapter-item "><a href="../BackwardProofs/BasicTactics.lean.html"><strong aria-hidden="true">2.2.</strong> Basic Tactics</a></li><li class="chapter-item "><a href="../BackwardProofs/ConnectivesAndQuantifiers.lean.html"><strong aria-hidden="true">2.3.</strong> Reasoning about Connectives and Quantifiers</a></li><li class="chapter-item "><a href="../BackwardProofs/Equality.lean.html"><strong aria-hidden="true">2.4.</strong> Reasoning about Equality</a></li><li class="chapter-item "><a href="../BackwardProofs/RewritingTactics.lean.html"><strong aria-hidden="true">2.5.</strong> Rewriting Tactics</a></li><li class="chapter-item "><a href="../BackwardProofs/Induction.lean.html"><strong aria-hidden="true">2.6.</strong> Proofs by Mathematical Induction</a></li><li class="chapter-item "><a href="../BackwardProofs/InductionTactic.lean.html"><strong aria-hidden="true">2.7.</strong> Induction Tactic</a></li><li class="chapter-item "><a href="../BackwardProofs/CleanupTactics.lean.html"><strong aria-hidden="true">2.8.</strong> Cleanup Tactics</a></li><li class="chapter-item "><a href="../BackwardProofs/Summary.lean.html"><strong aria-hidden="true">2.9.</strong> Summary of New Lean Constructs</a></li></ol></li><li class="chapter-item "><a href="../ForwardProofs.lean.html"><strong aria-hidden="true">3.</strong> Forward Proofs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ForwardProofs/StructuredProofs.lean.html"><strong aria-hidden="true">3.1.</strong> Structured Proofs</a></li><li class="chapter-item "><a href="../ForwardProofs/StructuredConstructs.lean.html"><strong aria-hidden="true">3.2.</strong> Structured Constructs</a></li><li class="chapter-item "><a href="../ForwardProofs/Connectives.lean.html"><strong aria-hidden="true">3.3.</strong> Forward Reasoning about Connectives and Quantifiers</a></li><li class="chapter-item "><a href="../ForwardProofs/CalculationProofs.lean.html"><strong aria-hidden="true">3.4.</strong> Calculation Proofs</a></li><li class="chapter-item "><a href="../ForwardProofs/ForwardTactics.lean.html"><strong aria-hidden="true">3.5.</strong> Forward Reasoning with Tactics</a></li><li class="chapter-item "><a href="../ForwardProofs/DependentTypes.lean.html"><strong aria-hidden="true">3.6.</strong> Dependent Types</a></li><li class="chapter-item "><a href="../ForwardProofs/CurryHoward.lean.html"><strong aria-hidden="true">3.7.</strong> The Curry–Howard Correspondence</a></li><li class="chapter-item "><a href="../ForwardProofs/InductionPatterns.lean.html"><strong aria-hidden="true">3.8.</strong> Induction by Pattern Matching</a></li><li class="chapter-item "><a href="../ForwardProofs/Summary.lean.html"><strong aria-hidden="true">3.9.</strong> Summary of New Lean Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../FunctionalProgramming.lean.html"><strong aria-hidden="true">4.</strong> Functional Programming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../FunctionalProgramming/InductiveTypes.lean.html"><strong aria-hidden="true">4.1.</strong> Inductive Types</a></li><li class="chapter-item expanded "><a href="../FunctionalProgramming/StructuralInduction.lean.html" class="active"><strong aria-hidden="true">4.2.</strong> Structural Induction</a></li><li class="chapter-item "><a href="../FunctionalProgramming/StructuralRecursion.lean.html"><strong aria-hidden="true">4.3.</strong> Structural Recursion</a></li></ol></li><li class="chapter-item "><a href="../bib.html"><strong aria-hidden="true">5.</strong> Bibliography</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hitchhiker’s Guide to Logical Verification</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/leanprover/HitchikersGuide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Mathlib.Tactic.Basic
<span class="kn">import</span> Mathlib.Tactic.Cases
<span class="kn">import</span> Mathlib.Init.Data.Nat.Basic</span></span></pre>
<h2 id="structural-induction"><a class="header" href="#structural-induction">Structural Induction</a></h2>
<p><em>Structural induction</em> is a generalization of mathematical induction to arbitrary inductive types.
To prove a goal <code>n : ℕ ⊢ P[n]</code> by structural induction on <code>n</code>, it suffces to show two subgoals,
traditionally called the base case and the induction step:</p>
<pre><code class="language-lean">⊢ P[0]
k : ℕ,ih : P[k] ⊢ P[k + 1]</code></pre>
<p>We can of course also write <code>Nat.zero</code> and <code>Nat.succ k</code>.</p>
<p>In general, the situation is more complex. The goal might contain some extra hypotheses (e.g., <code>Q</code>)
that do not depend on <code>n</code> and others (e.g., <code>R[n]</code>) that do. Assuming we have one hypothesis of each
kind, this gives the initial goal</p>
<pre><code class="language-lean">hQ : Q, n : N, hR : R[n] ⊢ S[n]</code></pre>
<p>Structural induction on <code>n</code> then produces the two subgoals</p>
<pre><code class="language-lean">hQ : Q, hR : R[0] ⊢ S[0]
hQ : Q, k : N, ih : R[k] → S[k], hR : R[k + 1] ⊢ S[k + 1]</code></pre>
<p>The hypothesis <code>Q</code> is simply carried over unchanged from the initial goal, whereas
<code>R[n] ⊢ S[n]</code> is treated almost the same as if the goal’s target had been
<code>R[n] → S[n]</code>. This is easy to check by taking <code>P[n] := R[n] → S[n]</code> in the first example
above. Since this general format is very verbose and hardly informative (now that
we understand how it works), from now on we will present goals in the simplest
form possible, without extra hypotheses.</p>
<p>For lists, given a goal <code>xs : List α ⊢ P[xs]</code>, structural induction on <code>xs</code> yields</p>
<pre><code class="language-lean">⊢ P[[]]
y : α, ys : List α, ih : P[ys] ⊢ P[y :: ys]</code></pre>
<p>We can of course also write <code>List.nil</code> and <code>List.cons y ys</code>. There is no induction hypothesis
associated with <code>y</code>, because <code>y</code> is not of List type.</p>
<p>For arithmetic expressions, the base cases are</p>
<pre><code>i : ℤ ⊢ P[Aexp.num i]                    x : string ⊢ P[Aexp.var x]
</code></pre>
<p>and the induction steps for <code>add</code>, <code>sub</code>, <code>mul</code> and <code>div</code> are</p>
<pre><code>e₁ e₂ : Aexp, ih₁ : P[e₁], ih₂ : P[e₂] ⊢ P[Aexp.add e₁ e₂]
e₁ e₂ : Aexp, ih₁ : P[e₁], ih₂ : P[e₂] ⊢ P[Aexp.sub e₁ e₂]
e₁ e₂ : Aexp, ih₁ : P[e₁], ih₂ : P[e₂] ⊢ P[Aexp.mul e₁ e₂]
e₁ e₂ : Aexp, ih₁ : P[e₁], ih₂ : P[e₂] ⊢ P[Aexp.div e₁ e₂]
</code></pre>
<p>Notice the two induction hypotheses, about e₁ and e₂.</p>
<p>In general, structural induction produces one subgoal per constructor. In each subgoal, induction
hypotheses are available for all constructor arguments of the type we are performing the induction
on.</p>
<p>Regardless of the inductive type <code>τ</code>, the procedure to compute the subgoals is
always the same:</p>
<ol>
<li>Replace the hole in <code>P[ ]</code> with each possible constructor applied to fresh
variables (e.g., <code>y :: ys</code>), yielding as many subgoals as there are constructors.</li>
<li>Add these new variables (e.g., <code>y</code>, <code>ys</code>) to the local context.</li>
<li>Add induction hypotheses for all new variables of type <code>τ</code>.</li>
</ol>
<p>As an example, we will prove that <code>Nat.succ n ≠ n</code> for all <code>n : ℕ</code>. We start with
an informal proof, because these require us to understand what we are doing:</p>
<p>The proof is by structural induction on <code>n</code>.</p>
<p><code>Case 0</code>: We must show <code>Nat.succ 0 ≠ 0</code>. This follows from the “no confusion” property
of the constructors of inductive types.</p>
<p><code>Case Nat.succ k</code>: The induction hypothesis is <code>Nat.succ k ≠ k</code>. We
must show <code>Nat.succ (Nat.succ k) ≠ Nat.succ k</code>. By the injectivity of
<code>Nat.succ</code>, we have that <code>Nat.succ (Nat.succ k) = Nat.succ k</code> is equivalent to
<code>Nat.succ k = k</code>. Thus, it suffces to prove <code>Nat.succ k ≠ k</code>,
which corresponds exactly to the induction hypothesis. <span class=qed></span></p>
<p>Notice the main features of this informal proof, which you should aim to reproduce in your own
informal arguments:</p>
<ul>
<li>The proof starts with an unambiguous announcement of the type of proof we are carrying out (e.g.,
which kind of induction and on which variable).</li>
<li>The cases are clearly identified, and for each case, both the goal’s target and the hypotheses are
stated.</li>
<li>The key lemmas on which the proof relies are explicitly invoked (e.g., injectivity of <code>Nat.succ</code>).</li>
</ul>
<p>Now let us carry out the proof in Lean:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat.succ_neq_self</var><b>: </b><span>∀ (n : ℕ), Nat.succ n ≠ n</span></span></div></blockquote></div></small></div><span class="nv">nat.succ_neq_self</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℕ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℕ</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>Nat.succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">≠</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.succ n <span class="bp">≠</span> n</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk1"><span class="alectryon-token"><span class="k">induction&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"> n ih</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">Nat.succ Nat.zero <span class="bp">≠</span> Nat.zero</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StructuralInduction-lean-chk2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>Nat.succ n <span class="bp">≠</span> n</span></span></span><br></div><label class="goal-separator" for="StructuralInduction-lean-chk2"><hr><span class="goal-name">succ</span></label><div class="goal-conclusion">Nat.succ (Nat.succ n) <span class="bp">≠</span> Nat.succ n</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk3"><span class="alectryon-token"><span class="c1">-- ih: Nat.succ n ≠ n</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.succ n <span class="bp">≠</span> n</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk4"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">Nat.succ Nat.zero <span class="bp">≠</span> Nat.zero</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk5"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk6"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>Nat.succ n <span class="bp">≠</span> n</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">Nat.succ (Nat.succ n) <span class="bp">≠</span> Nat.succ n</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">           </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk7"><span class="alectryon-token"><span class="c1">-- ⊢ Nat.succ Nat.zero ≠ Nat.zero</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.succ n <span class="bp">≠</span> n</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk8"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>Nat.succ n <span class="bp">≠</span> n</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">Nat.succ (Nat.succ n) <span class="bp">≠</span> Nat.succ n</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk9"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>Nat.succ n ≠ n</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chka"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">      <span class="c1">-- ⊢ Nat.succ (Nat.succ n) ≠ Nat.succ n</span></span></span></pre>
<p>The routine reasoning about constructors is all carried out by <code>simp</code> automatically,
which is usually what we want.</p>
<p>We can supply our own names, and reorder the cases, by using the case tactic
in front of each case, together with the case’s name and the desired names for
the variables and hypotheses introduced by <code>induction’</code>. For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat.succ_neq_self2</var><b>: </b><span>∀ (n : ℕ), Nat.succ n ≠ n</span></span></div></blockquote></div></small></div><span class="nv">nat.succ_neq_self2</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℕ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℕ</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>Nat.succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">≠</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chkb"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.succ n <span class="bp">≠</span> n</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chkc"><span class="alectryon-token"><span class="k">induction&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"> m IH</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">Nat.succ Nat.zero <span class="bp">≠</span> Nat.zero</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StructuralInduction-lean-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Nat.succ m <span class="bp">≠</span> m</span></span></span><br></div><label class="goal-separator" for="StructuralInduction-lean-chkd"><hr><span class="goal-name">succ</span></label><div class="goal-conclusion">Nat.succ (Nat.succ m) <span class="bp">≠</span> Nat.succ m</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chke"><span class="alectryon-token"><span class="k">case</span></span><span class="alectryon-token"> succ  <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Nat.succ m <span class="bp">≠</span> m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.succ (Nat.succ m) <span class="bp">≠</span> Nat.succ m</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chkf"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Nat.succ m <span class="bp">≠</span> m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.succ (Nat.succ m) <span class="bp">≠</span> Nat.succ m</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk10"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IH</var><b>: </b><span>Nat.succ m ≠ m</span></span></div></blockquote></div></small></div><span class="nv">IH</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk11"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk12"><span class="alectryon-token"><span class="k">case</span></span><span class="alectryon-token"> zero <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.succ Nat.zero <span class="bp">≠</span> Nat.zero</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk13"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.succ Nat.zero <span class="bp">≠</span> Nat.zero</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk14"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StructuralInduction-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="StructuralInduction-lean-chk15"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Instead of <code>n</code> and <code>ih</code>, we chose the names <code>m</code> and <code>IH</code> and we moved the zero
case to the end.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../FunctionalProgramming/InductiveTypes.lean.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../FunctionalProgramming/StructuralRecursion.lean.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../FunctionalProgramming/InductiveTypes.lean.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../FunctionalProgramming/StructuralRecursion.lean.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" charset="utf-8"></script>
        <script src="../mark.min.js" charset="utf-8"></script>
        <script src="../searcher.js" charset="utf-8"></script>

        <script src="../clipboard.min.js" charset="utf-8"></script>
        <script src="../highlight.js" charset="utf-8"></script>
        <script src="../book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script src="../alectryon.js"></script>


    </body>
</html>
