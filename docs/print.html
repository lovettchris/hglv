<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Hitchhiker’s Guide to Logical Verification</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="alectryon.css">
        <link rel="stylesheet" href="pygments.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="cover.html">Cover</a></li><li class="chapter-item affix "><a href="preface.html">Preface</a></li><li class="chapter-item "><a href="Basics/Definitions.lean.html"><strong aria-hidden="true">1.</strong> Definitions and Statements</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Basics/TypesAndTerms.lean.html"><strong aria-hidden="true">1.1.</strong> Types and Terms</a></li><li class="chapter-item "><a href="Basics/TypeDefinitions.lean.html"><strong aria-hidden="true">1.2.</strong> Types Definitions</a></li><li class="chapter-item "><a href="Basics/FunctionDefinitions.lean.html"><strong aria-hidden="true">1.3.</strong> Function Definitions</a></li><li class="chapter-item "><a href="Basics/TheoremStatements.lean.html"><strong aria-hidden="true">1.4.</strong> Theorem Statements</a></li><li class="chapter-item "><a href="Basics/Summary.html"><strong aria-hidden="true">1.5.</strong> Summary of New Lean Constructs</a></li></ol></li><li class="chapter-item "><a href="BackwardProofs/BackwardProofs.lean.html"><strong aria-hidden="true">2.</strong> Backward Proofs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="BackwardProofs/TacticMode.lean.html"><strong aria-hidden="true">2.1.</strong> Tactic Mode</a></li><li class="chapter-item "><a href="BackwardProofs/BasicTactics.lean.html"><strong aria-hidden="true">2.2.</strong> Basic Tactics</a></li><li class="chapter-item "><a href="BackwardProofs/ConnectivesAndQuantifiers.lean.html"><strong aria-hidden="true">2.3.</strong> Reasoning about Connectives and Quantifiers</a></li><li class="chapter-item "><a href="BackwardProofs/Equality.lean.html"><strong aria-hidden="true">2.4.</strong> Reasoning about Equality</a></li><li class="chapter-item "><a href="BackwardProofs/RewritingTactics.lean.html"><strong aria-hidden="true">2.5.</strong> Rewriting Tactics</a></li><li class="chapter-item "><a href="BackwardProofs/Induction.lean.html"><strong aria-hidden="true">2.6.</strong> Proofs by Mathematical Induction</a></li><li class="chapter-item "><a href="BackwardProofs/InductionTactic.lean.html"><strong aria-hidden="true">2.7.</strong> Induction Tactic</a></li><li class="chapter-item "><a href="BackwardProofs/CleanupTactics.lean.html"><strong aria-hidden="true">2.8.</strong> Cleanup Tactics</a></li><li class="chapter-item "><a href="BackwardProofs/Summary.lean.html"><strong aria-hidden="true">2.9.</strong> Summary of New Lean Constructs</a></li></ol></li><li class="chapter-item "><a href="bib.html"><strong aria-hidden="true">3.</strong> Bibliography</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hitchhiker’s Guide to Logical Verification</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/leanprover/HitchikersGuide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="anne-baanen"><a class="header" href="#anne-baanen">Anne Baanen</a></h2>
<h2 id="alexander-bentkamp"><a class="header" href="#alexander-bentkamp">Alexander Bentkamp</a></h2>
<h2 id="jasmin-blanchette"><a class="header" href="#jasmin-blanchette">Jasmin Blanchette</a></h2>
<h2 id="johannes-hölzl"><a class="header" href="#johannes-hölzl">Johannes Hölzl</a></h2>
<h2 id="jannis-limperg"><a class="header" href="#jannis-limperg">Jannis Limperg</a></h2>
<p><br/><br/><br/><br/><br/></p>
<p style="text-align:right;font-size:36pt;font-style:italic">
The Hitchhiker’s Guide to</br>
Logical Verification
</p>
<p><br/><br/></p>
<h3 id="2022-standard-edition"><a class="header" href="#2022-standard-edition">2022 Standard Edition</a></h3>
<p>(October 25, 2022)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>Formal proof assistants are software tools designed to help their users carry out computer-checked
proofs in a logical calculus. We usually call them <em>proof assistants</em>, or <em>interactive theorem
provers</em>, but a mischievous student coined the phase “proof-preventing beasts,” and dictation
software occasionally misunderstands “theorem prover” as “fear improver.” Consider yourself warned.</p>
<p><strong>Rigorous and Formal Proofs</strong> Interactive theorem proving has its own terminology, already starting
with the notion of “proof.” A <em>formal proof</em> is a logical argument expressed in a logical formalism.
In this context, “formal” means “logical” or “logic-based.” Logicians—the mathematicians of
logics—carried out formal proofs on papers decades before the advent of computers, but nowadays
formal proofs are almost always carried out using a proof assistant.</p>
<p>In contrast, an <em>informal proof</em> is what a mathematician would normally call a proof. These are
often carried out in \(\LaTeX\) or on a blackboard, and are also called “pen-and-paper proofs.” The level
of detail can vary a lot, and phrases such as “it is obvious that,” “clearly,” and “without loss of
generality” move some of the proof burden onto the reader. A rigorous proof is a very detailed
informal proof.</p>
<p>The main strength of proof assistants is that they help develop highly trustworthy, unambiguous
proofs of mathematical statements, using a precise logic. They can be used to prove arbitrarily
advanced results, and not only toy examples or logic puzzles. Formal proofs also help students
understand what constitutes a valid definition or a valid proof. To quote <a href="https://www.scottaaronson.com/teaching.pdf">Scott
Aaronson</a>:</p>
<blockquote>
<p>I still remember having to grade hundreds of exams where the students started out by assuming what
had to be proved, or filled page after page with gibberish in the hope that, somewhere in the mess,
they might accidentally have said something correct.</p>
</blockquote>
<p>When we develop a new theory, formal proofs can help us explore it. They are useful when we
generalize, refactor, or otherwise modify an existing proof, in much the same way as a compiler
helps us develop correct programs. They give a high level of trustworthiness that makes it easier
for others to review the proof. In addition, formal proofs can form the basis of verified
computational tools (e.g., verified computer algebra systems).</p>
<p><strong>Success Stories</strong> There have been a number of success stories in mathematics and computer science.
Three landmark results in the formalization of mathematics have been the proof of the <a href="../bib.html#8">four-color
theorem</a> by Gonthier et al., the proof of the
<a href="../bib.html#9">odd-order theorem</a> by Gonthier et al., and the proof of
the <a href="../bib.html#12">Kepler conjecture</a> by Hales et al.. The earliest work in this
area was carried out by Nicolaas de Bruijn and his colleagues starting in the 1960s in a system
called <a href="https://www.win.tue.nl/automath/">AUTOMATH</a>.</p>
<p>Today, few mathematicians use proof assistants, but this is slowly changing. For example, 29
participants of the <a href="https://lean-forward.github.io/lean-together/2019/index.html">Lean Together 2019 meeting in
Amsterdam</a>, about formalization of
mathematics, self-identified as mathematicians.</p>
<p>Most users of proof assistants today are computer scientists. A few companies, including
<a href="../bib.html#32">AMD</a> and <a href="../bib.html#13">Intel</a>, have been using proof assistants to verify their
designs. In academia, some of the milestones are the verifications of the operating system kernels
<a href="../bib.html#16">seL4</a> and <a href="../bib.html#11">CertiKOS</a> and the development of the verified compilers
<a href="../bib.html#19">CompCert</a>, <a href="../bib.html#23">JinjaThreads</a>, and <a href="../bib.html#18">CakeML</a>.</p>
<p><strong>Proof Assistants</strong> There are dozens of proof assistants in development or use across the world. A
list of the main ones follows, classified by logical foundations:</p>
<ul>
<li>set theory: Isabelle/ZF, Metamath, Mizar;</li>
<li>simple type theory: HOL4, HOL Light, Isabelle/HOL;</li>
<li>dependent type theory: Agda, Coq, Lean, Matita, PVS;</li>
<li>Lisp-like first-order logic: ACL2.</li>
</ul>
<p>For a history of proof assistants and interactive theorem proving, we refer to Harrison, Urban, and
Wiedijk’s <a href="../bib.html#14">highly informative chapter</a>.</p>
<p><strong>Lean</strong> Lean is a new proof assistant developed primarily by Leonardo de Moura (Microsoft Research)
since 2012. Its mathematical library, <a href="https://arxiv.org/pdf/1910.09336.pdf">mathlib</a>, was
originally developed under the leadership of Jeremy Avigad (Carnegie Mellon University) but is now
maintained and further extended by an <a href="../bib.html#24">active users’ community</a>.</p>
<p>We will use Lean community version 4, mathlib4, and a few extensions collected in a small library
called <a href="https://github.com/blanchette/logical_verification_2021/raw/main/lean/lovelib.lean">LoVelib</a>.
Although it is still a research project, with some rough edges, there are several reasons why Lean
is a suitable vehicle to teach interactive theorem proving:</p>
<ul>
<li>It has a highly expressive, and highly interesting, logic based on the calculus of inductive
constructions, a dependent type theory.</li>
<li>It is extended with classical axioms and quotient types, making it convenient to verify
mathematics.</li>
<li>It includes a convenient metaprogramming framework, which can be used to program custom proof
automation.</li>
<li>It includes a modern user interface via a <a href="https://marketplace.visualstudio.com/items?itemName=leanprover.lean4">Visual Studio Code
plugin</a>.</li>
<li>It has highly readable, fairly complete documentation.</li>
<li>It is open source and cross-platform.</li>
</ul>
<p>Lean’s core library includes only basic algebraic definitions. More setup and proof automation are
found in mathlib. It is more than a mathematical library; it provides a lot of basic automation on
top of Lean’s core library that one would expect from a modern proof assistant.</p>
<p><strong>This Guide</strong> This guide is a companion to the MSc-level course Logical Verification (LoVe) taught
at the Vrije Universiteit Amsterdam. Our primary aim is to teach interactive theorem proving. Lean
is the vehicle, not an end of itself. As such, this guide is not designed to be a comprehensive Lean
tutorial—for this, we recommend <a href="../bib.html#1">Theorem Proving in Lean</a>.
The guide is also no substitute for attending class or doing the exercises and homework.
Theorem proving is not for spectators; it can only be learned by doing.</p>
<p>Specifically, our goal is that you</p>
<ul>
<li>learn fundamental theory and techniques in interactive theorem proving;</li>
<li>learn how to use logic as a precise language for modeling systems and stating properties about them;</li>
<li>familiarize yourselves with some areas in which proof assistants are successfully applied, such as
functional programming, the semantics of imperative programming languages, and mathematics;</li>
<li>develop some practical skills you can apply on a larger project (as a hobby, for an MSc or PhD, or in industry);</li>
<li>reach a point where you feel ready to move to another proof assistant and apply what you have learned;</li>
<li>get to understand the domain well enough to start reading relevant scientific papers published at
international conferences such as Certified Programs and Proofs (CPP) and Interactive Theorem
Proving (ITP) or in journals such as the <em>Journal of Automated Reasoning</em> (JAR).</li>
</ul>
<p>Equipped with a good knowledge of Lean, you will find it easy to move to another proof assistant
based on dependent type theory, such as Agda or Coq, or to a system based on simple type theory,
such as HOL4 or Isabelle/HOL</p>
<p>We assume that you are familiar with typed functional programming, as embodied in the languages
Haskell, OCaml, and Standard ML. If you do not see that the term <code>g (f a b)</code> applies the (curried)
function <code>f</code> to two arguments <code>a</code> and <code>b</code> and passes the result to the function <code>g</code>, or that <code>λ n =&gt; n + 1</code> is
the function that maps <code>n</code> to <code>n + 1</code>, we strongly recommend that you start by studying a tutorial, such
as the first chapters of the online tutorial <a href="../bib.html#22">Learn You a Haskell for Great Good!</a>.
You can stop reading once you have reached the end of the section titled “Lambdas.”</p>
<p>An important characteristic of this guide, which it shares with <a href="../bib.html#17">Knuth’s \(\TeX\) book</a>,
is that it does not always tell the truth. To simplify the exposition, simple but
false claims are made about Lean. Some of these statements are rectified in later
chapters. Like Knuth, we feel that <em>“this technique of deliberate lying will actually
make it easier for you to learn the ideas. Once you understand a simple but false
rule, it will not be hard to supplement that rule with its exceptions.”</em></p>
<p>The Lean files accompanying this guide can be found in the <a href="https://github.com/leanprover/HitchikersGuide">public repository</a>.
The files’ naming scheme follows this guide’s chapters; thus, <code>06_monads_demo</code>.
lean is the main file associated with Chapter 6 (“Monads”), which is demonstrated
in class, <code>06_monads_exercise_sheet.lean</code> is the exercise sheet, and <code>06_monads_homework_sheet.lean</code>
is the homework sheet.</p>
<p>We have a huge debt to the authors of <a href="../bib.html#1">Theorem Proving in Lean</a>
and <a href="../bib.html#27">Concrete Semantics: With Isabelle/HOL</a>,
who have taught us Lean and programming language semantics. Many of their ideas appear in this guide.</p>
<p>We thank Robert Lewis and Assia Mahboubi for their useful comments on this guide’s organization and
focus. We thank Kiran Gopinathan and Ilya Sergey for sharing the anecdote reported in footnote 3 of
Chapter 1 and letting us share it further. We thank Daniel Fabian for designing the first
tablet-optimized version of this guide. Finally, we thank Chris Bailey, Kevin Buzzard, Wan Fokkink,
Robert Lewis, Antonius Danny Reyes, Robert Schütz, Patrick Thomas, Huub Vromen, and Wijnand van
Woerkom for reporting typos and some more serious errors they found in earlier editions of this
guide. Should you find some mistakes in this text, please let us know.</p>
<p><strong>Special Symbols</strong> In this guide, we assume that you will be using <a href="https://code.visualstudio.com/Download">Visual Studio
Code</a> and its <a href="https://marketplace.visualstudio.com/items?itemName=leanprover.lean4">Lean 4
extension</a> to edit .lean
files. Visual Studio Code lets us enter Unicode symbols by entering backslash \ followed by an ASCII
identifier. For example, →, λ, or ∀  can be entered by typing <code>\r</code>, <code>\la</code>, or <code>\all</code> and pressing the tab key
or the space bar. We will freely use these notations. For reference, we provide a list of the main
non-ASCII symbols that are used in the guide and, for each, one of its ASCII representations. By
hovering over a symbol in Visual Studio Code while holding the control or command key pressed, you
will see the different ways in which it can be entered.</p>
<div class="table-wrapper"><table><thead><tr><th>symbol</th><th>abbreviation</th><th>symbol</th><th>abbreviation</th><th>symbol</th><th>abbreviation</th></tr></thead><tbody>
<tr><td>¬</td><td>\not</td><td>∧</td><td>\and</td><td>∨</td><td>\or</td></tr>
<tr><td>→</td><td>\r</td><td>←</td><td>\l</td><td>↔</td><td>\lr</td></tr>
<tr><td>∃</td><td>\ex</td><td>∀</td><td>\fo</td><td>∑</td><td>\S</td></tr>
<tr><td>≤</td><td>\&lt;=</td><td>≥</td><td>\&gt;=</td><td>≠</td><td>\neq</td></tr>
<tr><td>≈</td><td>\~~</td><td>×</td><td>\x</td><td>⊕</td><td>\oplus</td></tr>
<tr><td>◦</td><td>\circ</td><td>∅</td><td>\em</td><td>∪</td><td>\union</td></tr>
<tr><td>∩</td><td>\intersect</td><td>∈</td><td>\in</td><td>⇃</td><td>\downleftharpoon</td></tr>
<tr><td>◯</td><td>\bigcirc</td><td>↦</td><td>\mapsto</td><td>⇒</td><td>\=&gt;</td></tr>
<tr><td>⟹</td><td>\==&gt;</td><td>⟦</td><td>\[[</td><td>⟧</td><td>\]]</td></tr>
<tr><td>ℕ</td><td>\N</td><td>ℤ</td><td>\Z</td><td>ℚ</td><td>\Q</td></tr>
<tr><td>ℝ</td><td>\R</td><td>α</td><td>\a</td><td>β</td><td>\b</td></tr>
<tr><td>γ</td><td>\g</td><td>δ</td><td>\de</td><td>ε</td><td>\e</td></tr>
<tr><td>λ</td><td>\la</td><td>σ</td><td>\s</td><td>₀</td><td>\0</td></tr>
<tr><td>₁</td><td>\1</td><td>₂</td><td>\2</td><td>₃</td><td>\3</td></tr>
<tr><td>₄</td><td>\4</td><td>₅</td><td>\5</td><td>₆</td><td>\6</td></tr>
<tr><td>₇</td><td>\7</td><td>₈</td><td>\8</td><td>₉</td><td>\9</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="definitions-and-statements"><a class="header" href="#definitions-and-statements">Definitions and Statements</a></h1>
<p>We start our journey by studying the basics of Lean, without carrying out any
proofs yet. We review how to define new types and functions and how to state
their expected properties as lemmas.</p>
<p>Lean’s logical foundation is a rich formalism called the calculus of inductive
constructions, which supports dependent types. In this chapter, we restrict our
attention to its simply (i.e., nondependently) typed fragment. It is inspired by
the λ-calculus and resembles typed functional programming languages such as
Haskell, OCaml, and Standard ML. Even if you have not been exposed to these
languages, you will recognize many of the concepts from modern languages (e.g.,
Python, C++11, Java 8). In a first approximation:</p>
<blockquote>
<p>Lean = functional programming + logid</p>
</blockquote>
<p>If your background is in mathematics, you probably already know most of
the key concepts underlying functional programming, sometimes under different
names. For example, the Haskell program:</p>
<pre><code class="language-haskell">fib 0 = 0
fib 1 = 1
fib n = fib (n - 2) + fib (n - 1)
</code></pre>
<p>closely matches the mathematical definition:</p>
<p>\( fib(n) = \begin{cases} 0 &amp; \text{if } n = 0 \\ 1 &amp; \text{if } n = 1 \\ fib(n - 2) + fib(n - 1) &amp; \text{if } n ≥ 2 \end{cases} \)</p>
<p>and which can be written in Lean as:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fib</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div><span class="nv">fib</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">     <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">     <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"><span class="bp">+</span><span class="mi">2</span>) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fib</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div><span class="nv">fib</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fib</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div><span class="nv">fib</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"><span class="bp">+</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Definitions-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Definitions-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">55</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fib</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>fib</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token">    <span class="c1">-- 55</span></span></span></pre><div style="break-before: page; page-break-before: always;"></div><h2 id="types-and-terms"><a class="header" href="#types-and-terms">Types and Terms</a></h2>
<p><em>Simple type theory</em> (also called higher-order logic) corresponds roughly to the
<a href="Basics/../bib.html#5">simply typed λ-calculus</a> extended with an equality operator (=). It is an abstract,
extremely simplified version of a programming language with a function-calling
mechanism that prefigures functional programming. It can also be viewed as a
generalization of first-order logic (also called predicate logic).</p>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>Types are either basic types such as <code>ℤ</code>, <code>ℚ</code>, and bool or total functions <code>σ → τ</code>, where
<code>σ</code> and <code>τ</code> are themselves types. Types indicate which values an expression may
evaluate to. They introduce a discipline that is followed somewhat implicitly in
mathematics. In principle, nothing prevents a mathematician from stating <code>1 ∈ 2</code>,
but a typing discipline would mark this as the error it likely is.</p>
<p>Semantically, types can be viewed as sets. We would normally define the types
<code>ℤ</code>, <code>ℚ</code>, and <code>bool</code> so that they faithfully capture the mathematicians’ <code>ℤ</code> and <code>ℚ</code> and
the computer scientists’ Booleans, and similarly for the function arrow (<code>→</code>). But
despite their similarities, Lean and mathematics are distinct languages. Lean’s
types may be interpreted as sets, but they are not sets.</p>
<p>Higher-order types are types containing left-nested <code>→</code> arrows. Values of such
types are functions that take other functions as arguments. Accordingly, the type
<code>(ℤ → ℤ) → ℚ</code>  is the type of unary functions that take a function of type <code>ℤ → ℤ</code> as
argument and that return a value of type <code>ℚ</code>.</p>
<h3 id="terms"><a class="header" href="#terms">Terms</a></h3>
<p>The <em>terms</em>, or expressions, of simple type theory consist of</p>
<ul>
<li><em>constants</em> c;</li>
<li><em>variables</em> x;</li>
<li><em>applications</em> t u;</li>
<li><em>λ-expressions</em> λx =&gt; t.</li>
</ul>
<p>Above, <code>t</code> and <code>u</code> denote arbitrary terms. We can also write <code>t : σ</code> to indicate that the
term <code>t</code> has the type <code>σ</code>.</p>
<p>A constant <code>c : σ</code> is a symbol of type <code>σ</code> whose meaning is fixed in the current
global context. For example, an arithmetic theory might contain constants such
as <code>0 : ℤ</code>, <code>1 : ℤ</code>, <code>abs : ℤ → ℕ</code>, <code>square : ℕ → ℕ</code>, and <code>prime : ℕ → Bool</code>. Constants
include functions (e.g., <code>abs</code>) and predicates (e.g., <code>prime</code>).</p>
<p>A variable <code>x : σ</code> is either bound or free. A bound variable refers back to the
input of a λ-expression <code>λ x : σ =&gt; t</code> enclosing it. In <code>λ x : ℤ =&gt; square (abs x)</code>
the second <code>x</code> is a variable that refers back to the λ binder’s input <code>x</code>. By contrast, a free
variable is declared in the local context—a concept that will be explained below.</p>
<p>An application <code>t u</code>, where <code>t : σ → τ</code> and <code>u : σ</code>, is a term of type <code>τ</code> denoting the
result of applying the function <code>t</code> to the argument <code>u</code>—e.g., <code>abs 0</code>. No parentheses
are needed around the argument, unless it is a complex term—e.g., <code>prime (abs 0)</code>.</p>
<p>Given a term <code>t : τ</code>, a λ-expression <code>λ x : σ =&gt; t</code> denotes the total function of type
<code>σ → τ</code> that maps each input value <code>x</code> of type <code>σ</code> to the function body <code>t</code>, where <code>t</code> may
contain <code>x</code>. For example, <code>λ x : ℤ =&gt; square (abs x)</code> denotes the function that maps
(the value denoted by) <code>0</code> to (the value denoted by) <code>square (abs 0)</code>, that maps <code>1</code> to
<code>square (abs 1)</code>, and so on. A more intuitive syntax might have been
<code>x ↦ square (abs x)</code>, but this is not supported by Lean.</p>
<p>Applications and λ-expressions mirror each other: A λ-expression “builds” a
function; an application “destructs” a function. Although our functions are unary
(i.e., they take one argument), we can build <em>n</em>-ary functions by nesting λs, using
an ingenious technique called <em>currying</em>. For example, <code>λ x : σ =&gt; (λy : τ, x)</code> denotes
the function of type <code>σ → (τ → σ)</code> that takes two arguments and returns the first
one. Strictly speaking, <code>σ → (τ → σ)</code> takes a single argument and returns a function,
which in turn takes an argument. Applications work in the same way: If
<code>K := (λx : ℤ =&gt; (λ y : Z =&gt; x))</code>, then <code>K 1 = (λ y : Z =&gt; 1)</code> and <code>(K 1) 0 = 1</code>.
The function <code>K</code> in <code>K 1</code>, which is applied to a single argument, is said to be <em>partially applied</em>.</p>
<p>Currying is so useful a concept that we will omit most parentheses, writing</p>
<ul>
<li><code>σ → τ → υ</code> for <code>σ → (τ → υ)</code></li>
<li><code>t u v</code> for <code>(t u) v</code></li>
<li><code>λ x : σ =&gt; λ y : τ =&gt; t</code> for <code>λ x : σ =&gt; </code>(λ y : τ =&gt; t)`</li>
</ul>
<p>and also</p>
<ul>
<li><code>λ (x : σ) (y : τ) =&gt; t</code> for <code>λ x : σ =&gt; λ y : τ =&gt; t</code></li>
<li><code>λ x y : σ =&gt; t</code> for <code>λ (x : σ) (y : σ) =&gt; t</code></li>
</ul>
<p>In mathematics, it is customary to write binary operators in infix syntax—e.g.,
<code>x + y</code>. Such notations are also possible in Lean, as syntactic sugar for <code>Add.add x y</code>.
Partial application is possible with this syntax. For example,  <code>Add.add 1</code>
denotes the unary function that adds one to its argument. Other ways to write
this function are <code>λ x =&gt; Add.add 1 x</code> and <code>λ x =&gt; 1 + x</code>.</p>
<p>No we can move some of this into the Lean language, declaring some simple
typed values and functions using the <code>def</code> command as follows:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">notation</span></span><span class="alectryon-token"> <span class="s2">&quot;ℤ&quot;</span> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Int</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Int</span><span class="alectryon-token">   <span class="c1">-- associates the notation ℤ with Integer type.</span>
</span><span class="alectryon-token"><span class="kd">notation</span></span><span class="alectryon-token"> <span class="s2">&quot;ℕ&quot;</span> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">   <span class="c1">-- associates the notation ℕ with Nat type for natural numbers.</span>

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℤ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℤ</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℤ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℤ</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>ℤ → ℤ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℤ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℤ</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℤ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℤ</span><span class="alectryon-token">  := <span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>ℤ → ℤ → ℤ</span></span></div></blockquote></div></small></div><span class="nv">g</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℤ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℤ</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℤ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℤ</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℤ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℤ</span><span class="alectryon-token"> := <span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TypesAndTerms-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="TypesAndTerms-lean-chk0"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="k">fun</span> x <span class="bp">=&gt;</span> g (f (g a x)) (g x b) : ℤ <span class="bp">→</span> ℤ</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℤ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℤ</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>ℤ → ℤ → ℤ</span></span></div></blockquote></div></small></div>g</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>ℤ → ℤ</span></span></div></blockquote></div></small></div>f</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>ℤ → ℤ → ℤ</span></span></div></blockquote></div></small></div>g</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div>a</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>ℤ → ℤ → ℤ</span></span></div></blockquote></div></small></div>g</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div>b</span><span class="alectryon-token">)   <span class="c1">-- ℤ → ℤ</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TypesAndTerms-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="TypesAndTerms-lean-chk1"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="k">fun</span> x <span class="bp">=&gt;</span> g (f (g a x)) (g x b) : ℤ <span class="bp">→</span> ℤ</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>ℤ → ℤ → ℤ</span></span></div></blockquote></div></small></div>g</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>ℤ → ℤ</span></span></div></blockquote></div></small></div>f</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>ℤ → ℤ → ℤ</span></span></div></blockquote></div></small></div>g</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div>a</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>ℤ → ℤ → ℤ</span></span></div></blockquote></div></small></div>g</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div>b</span><span class="alectryon-token">)       <span class="c1">-- ℤ → ℤ</span></span></span></pre>
<p>The first two lines declare tow constants (a, b), both of type Integer with
the respective value of 1 and 2.  The definition for <code>f</code> defines a funciton
of type <code>ℤ → ℤ</code> implemented by a lambda expression that adds 1 to its argument.
The definition for <code>g</code> defines a function of type <code>ℤ → ℤ → ℤ</code> implemented by a
lambda expression that takes two arguments and adds them together.</p>
<p>The last two lines use the <code>#check</code> command to type-check some terms and
show their types. The # prefix identifies interactive commands: commands that are
useful for debugging but that we would normally not keep in a Lean program.</p>
<p>The <code>abbrev</code> command can be used to define a new name for an existing type:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="k">abbrev</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>foo</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">foo</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Int</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Int</span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TypesAndTerms-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="TypesAndTerms-lean-chk2"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">foo : <span class="kt">Type</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>foo</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>foo</span><span class="alectryon-token"> <span class="c1">-- foo : Type</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TypesAndTerms-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="TypesAndTerms-lean-chk3"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">5</span> : foo</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>foo</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>foo</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>foo</span><span class="alectryon-token">)    <span class="c1">-- 5 : foo</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TypesAndTerms-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="TypesAndTerms-lean-chk4"><span class="alectryon-token"><span class="k">#reduce</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Int.ofNat <span class="mi">5</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>foo</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>foo</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>foo</span><span class="alectryon-token">)   <span class="c1">-- Int.ofNat 5</span></span></span></pre>
<p>Here we see that <code>foo</code> is a <code>Type</code> and it is synonymous for the type <code>Int</code>.</p>
<h3 id="type-checking-and-type-inference"><a class="header" href="#type-checking-and-type-inference">Type Checking and Type Inference</a></h3>
<p>When Lean parses a term, it checks whether the term is well typed. In the process,
it tries to infer the types of bound variables if those are omitted—e.g., the type of
<code>x</code> in <code>λ x =&gt; 1 + x</code>. Type inference lightens notations and saves some typing.</p>
<p>For simple type theory, type checking and type inference are decidable problems.
Advanced features such as overloading (the possibility to reuse the same
name for several constants—e.g., <code>0 : ℕ</code>  and <code>0 : ℝ</code>) can lead to <a href="Basics/../bib.html#30">undecidability</a>.
Lean takes a pragmatic, computer-science-oriented approach and assumes that
numerals <code>0, 1, 2, . . .</code> are of type <code>Nat</code> if several types are possible.</p>
<p>Lean’s type system can be expressed as a formal system. A formal system
consists of judgments and of (derivation) rules for producing judgments. A typing
judgment has the form <code>C ⊢ t : σ</code>, meaning that term <code>t</code> has type <code>σ</code> in local context <code>C</code>.
The local context gives the types of the variables in <code>t</code> that are not bound by a <code>λ</code>.
The local context is used to keep track of the variables bound by λ’s outside <code>t</code>.
For a function definition, it will consist of the function’s parameters. For example,
in Lean, the right-hand side of the last equation of fib’s above would be type-checked
in a local context consisting of <code>n : ℕ</code>.</p>
<p>For simple type theory, there are four typing rules, one per kind of term:</p>
<p>\( \cfrac{}{C ⊢ c : σ} {\large C}{\normalsize ST} \quad \text{if c is declared with type σ } \)</p>
<p>\( \cfrac{}{C ⊢ x : σ} {\large V}{\normalsize AR} \quad \text{if x : σ is the last occurrence of x in C } \)</p>
<p>\( \cfrac{C ⊢ t : σ → τ \quad C ⊢ u : σ }{C ⊢ t\enspace{u} : τ} {\large A}{\normalsize PP} \)</p>
<p>\( \cfrac{C, x : σ ⊢ t : τ }{C ⊢ (λ\enspace{x} : σ =&gt; t) : σ → τ} {\large L}{\normalsize AM} \)</p>
<p>Each rule has zero or more premises (above the horizontal bar), a conclusion
(below the bar), and possibly a side condition. The premises are typing judgments,
whereas the side conditions are arbitrary mathematical conditions on the mathematical
variables occurring in the rule. To discharge the premises, we need to
continue performing a derivation upward, as we will see in a moment. As for the
side conditions, we can use the entire arsenal of mathematics to show that they
are true.</p>
<p>The first two rules, labeled <code>CST</code> and <code>VAR</code>, have no premises, but they have side
conditions that must be satisfied for the rules to apply. The last two rules take
one or two judgments as premises and produce a new judgment. <code>LAM</code> is the only
rule that modifies the local context: As we enter the body <code>t</code> of a λ-expression, we
need to record the existence of the bound variable <code>x</code> and its type to be ready when
we meet <code>x</code> in <code>t</code></p>
<p>We can use this rule system to prove that a given term is well typed by working our way backwards
(i.e., upwards) and applying the rules, building a formal derivation of a typing judgment. Like
natural trees, derivation trees are drawn with the root at the bottom. The derived judgment appears
at the root, and each branch ends with the application of a premise-less rule. Rule applications are
indicated by a horizontal bar and a label. The following typing derivation establishes that the term
<code>λ x : ℤ =&gt; abs x</code> has type <code>ℤ → ℕ</code>  in an arbitrary local context <code>C</code>:</p>
<p>\( \cfrac{ \cfrac{}{C, x : ℤ ⊢ abs : ℤ → ℕ} {\large C}{\normalsize ST} \quad \cfrac{}{C, x : ℤ ⊢ x : ℤ } {\large V}{\normalsize AR}} { \cfrac{C, x : ℤ ⊢ abs\enspace{x} : ℕ}{C ⊢ (λ\enspace{x} : ℤ =&gt; abs\enspace{x}): ℤ → ℕ} {\large C}{\normalsize ST} } {\large A}{\normalsize PP}\)</p>
<p>Reading the proof from the root upwards, notice how the local context is threaded
through and how it is extended by the <code>LAM</code> rule. The rule moves the variable bound
by the λ-expression to the local context, making an application of <code>VAR</code> possible
further up the tree. If the variable <code>x</code> is already declared in <code>C</code>, it becomes shadowed
by <code>x : ℤ</code> after entering the λ-expression.</p>
<p>The above type system only checks that terms are well typed. It does not check
that types are well formed. For example, <code>List ℤ</code>  is well formed, whereas <code>ℤ List</code>
and <code>List List</code> are ill-formed. For simple type theory, well-formedness is easy
to check: Only declared type constructors should be used, and each <em>n</em>-ary type
constructor should be passed exactly <em>n</em> type arguments.</p>
<p>As a side note, type inference is a generalization of type checking where the
types on the right-hand side of the colon (<code>:</code>) in judgments may be replaced by
placeholders. Lean’s type inference is based on an algorithm due to <a href="Basics/../bib.html#15">Hindley</a>
and <a href="Basics/../bib.html#25">Milner</a>, which also forms the basis of Haskell, OCaml, and Standard ML.
The algorithm generates type constraints involving type variables <code>?α, ?β, ?γ, . . .</code>,
and attempts to solve them using a type unification procedure. For example, when
inferring the type <code>?α</code> of <code>λ x =&gt; abs x</code>, Lean would perform the following schematic
type derivation:</p>
<p>\( \cfrac{ \cfrac{}{x :\thinspace{?β} ⊢ abs :\thinspace{?β} → γ} {\large C}{\normalsize ST} \quad \cfrac{}{x :\thinspace{?β} ⊢ x :\thinspace{?β}} {\large V}{\normalsize AR}} { \cfrac{x :\thinspace{?β} ⊢ abs\enspace{x}:\thinspace{?γ}}{⊢ (λ\enspace{x} =&gt; abs\enspace{x}) :\thinspace{?α}} {\large C}{\normalsize ST} } {\large A}{\normalsize PP}\)</p>
<p>In addition, Lean would generate the following constraints to ensure that all the
rule applications are legal:</p>
<ol>
<li>For the application of <code>LAM</code>, the type of <code>λ x =&gt; abs x</code> must be of the form <code>?β → ?γ</code>,
for some types <code>?β</code> and <code>?γ</code>. Thus, Lean would generate the constraint <code>?α = ?β → ?γ</code></li>
<li>For the application of <code>CST</code>, the type of <code>abs</code> must correspond to the declaration as <code>ℤ → ℕ</code>.
Thus, Lean would generate the constraint <code>?β → ?γ = ℤ → ℕ</code></li>
</ol>
<p>Solving the two constraints yields <code>?α := ℤ → ℕ</code>, which is indeed the type that Lean
infers for <code>λ x =&gt; abs x</code>.</p>
<h3 id="type-inhabitation"><a class="header" href="#type-inhabitation">Type Inhabitation</a></h3>
<p>Given a type <code>σ</code>, the type inhabitation problem consists of finding an “inhabitant”
of that type—a term of type <code>σ</code>—within the empty local context. It may seem like a
pointless exercise, but as we will see in Chapter 3, this problem is closely related
to that of finding a proof of a proposition. Seemingly silly exercises of the form
“find a term of type <code>σ</code>” are good practice towards mastery of theorem proving.</p>
<p>To create a term of a given type, start with the placeholder _ and recursively
apply a combination of the following two steps:</p>
<ol>
<li>
<p>If the type is of the form <code>σ → τ</code>, a possible inhabitant is an anonymous function,
of the form <code>λ x : σ =&gt; _</code>, where <code>_</code> is a placeholder for a missing term of
type <code>τ</code>. Lean will mark <code>_</code> as an error; if you hover over it in Visual Studio
Code, a tooltip will show the missing term’s type as well as any variables
declared in the local context.</p>
</li>
<li>
<p>Given a type <code>σ</code> (which may be a function type), you can use any constant <code>c</code>
or variable <code>x : τ₁ → · · · → τₙ → σ</code> to build a term of that type. For each
argument, you need to put a placeholder, yielding <code>c _ . . . _</code> or <code>x _ . . . _</code></p>
</li>
</ol>
<p>The placeholders can be eliminated recursively using the same procedure.
As an example, we will apply the procedure to find a term of type
<code>(α → β → γ) → ((β → α) → β) → α → γ</code>.</p>
<p>Initially, only step 1 is applicable, with <code>σ := α → β → γ</code> and <code>τ := ((β → α) → β) → α → γ</code>.
(Recall that <code>→</code> is right-associative: <code>σ → τ → υ</code> stands for <code>σ → (τ → υ)</code>.)
This results in the term <code>λ f =&gt; _</code>, which has the right type but has a placeholder left.
Since the argument <code>f</code> has type <code>σ</code>, a function type, it makes sense to use the name
<code>f</code> for it. Then we continue recursively with the placeholder, of type <code>τ</code>. Again, only
step 1 is possible, so we end up with the term <code>λ f =&gt; λ g =&gt; _</code>, where <code>g</code> has type
<code>(β → α) → β</code> and the placeholder has type <code>α → γ</code>. A third application of step 1 yields
<code>λ f =&gt; λ g =&gt; λ a =&gt; _</code>, where <code>a</code> has type <code>α</code> and the placeholder has type <code>γ</code>.</p>
<p>At this point, step 1 is no longer possible. Let us see if step 2 is applicable. The
context surrounding the placeholder contains the following variables:</p>
<pre><code class="language-lean">f : α → β → γ
g : (β → α) → β
a : α</code></pre>
<p>Recall that we are trying to build a term of type <code>γ</code>. The only variable we can use
to achieve this is <code>f</code>: It takes two arguments and returns a value of type <code>γ</code>. So
we replace the placeholder with the term <code>f _ _</code>, where the two new placeholders
stand for the two missing arguments. Putting everything together, we now have
the term <code>λ f =&gt; λ g =&gt; λ a =&gt; f _ _</code>.</p>
<p>Following f’s type, the placeholders are of type <code>α</code> and <code>β</code>, respectively. The first
placeholder is easy to fill, using step 2 again, by simply supplying <code>a</code>, of type <code>α</code>, with
no arguments. For the second placeholder, we apply step 2 with the variable <code>g</code>,
which is the only source of βs. Since <code>g</code> takes an argument, we must supply a
placeholder. This means our current term is <code>λ f =&gt; λ g =&gt; λ a =&gt; f a (g _)</code>.</p>
<p>We are almost done. The only placeholder left has type <code>β → α</code>, which is g’s
argument type. Applying step 1, we replace the placeholder with <code>λ b =&gt; _</code>, where <code>_</code>
has type <code>α</code>. Here, we can simply supply <code>a</code>. Our final term is
<code>λ f =&gt; λ g =&gt; λ a =&gt; f a (g (λ b, a))</code>—i.e., <code>λ f g a =&gt; f a (g (λb, a))</code>.</p>
<p>The above derivation was tedious but deterministic: At each point, either step
1 or 2 was applicable, but not both. In general, this will not always be the case.
For some other types, we might encounter dead ends and need to backtrack. We
might also fail altogether, with nowhere to backtrack to. Notably, with an empty
local context, it is impossible to supply a witness for <code>α</code>.</p>
<p>The key idea is that the term should be syntactically correct at all times. The
only red underlining we should see in Visual Studio Code should appear under the
placeholders. In general, a good principle for software development is to start
with a program that compiles, perform the smallest change possible to obtain a
new compiling program, and repeat until the program is complete.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h2>
<p>A distinguishing feature of Lean’s calculus of inductive constructions is its built-in
support for inductive types. An <em>inductive type</em> is a type whose values are built by
applying special constants called <em>constructors</em>. Inductive types are a concise way
of representing acyclic data in a program. You may know them under some other,
largely synonymous names, including algebraic data types, inductive data types,
freely generated data types, recursive data types, and data types.</p>
<h3 id="natural-numbers"><a class="header" href="#natural-numbers">Natural Numbers</a></h3>
<p>The “Hello, World!” example of inductive types is the type <code>Nat</code> natural numbers.
In Lean, it can be defined as follows:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">namespace</span></span><span class="alectryon-token"> my_nat

</span><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Nat</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>zero</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>zero</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Nat</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>succ</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>succ</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Nat</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Nat</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">end</span></span><span class="alectryon-token"> my_nat</span></span></pre>
<p>Note: we are placing this in a new nameapce <code>my_nat</code> so it does not conflict with the
built-in type.</p>
<p>The first line of the <code>inductive</code> type announces to the world that we are introducing a new type
called <code>Nat</code>, intended to represent the natural numbers. The second and third line declare two new
constructors, <code>Nat.zero</code> which is of type <code>Nat</code> and <code>Nat.succ</code> which has the function type <code>Nat → Nat</code>, that can be used to build values of type <code>Nat</code>. Following an established convention in
computer science and logic, counting starts at zero. The second constructor is what makes this
inductive definition interesting—it requires an argument of type <code>Nat</code> to produce a value of type
<code>Nat</code>. The terms</p>
<pre><code class="language-lean">Nat.zero
Nat.succ Nat.zero
Nat.succ (Nat.succ Nat.zero)
...</code></pre>
<p>denote the different values of type nat—zero, its successor, its successor’s successor, and so on.
This notation is called <em>unary</em>, or <em>Peano</em>, after the logician Giuseppe Peano. For an alternative
explanation of Peano numbers in Lean (and some groovy video game graphics), see Kevin Buzzard’s
article <a href="http://chalkdustmagazine.com/features/can-computers-prove-theorems/">Can computers prove theorems?</a>.</p>
<p>The general format of type declarations is</p>
<pre><code class="language-lean">inductive type-name (params₁ : type₁) . . . (paramsₖ : typeₖ) : Type
| constructor-name₁ : constructor-type₁
.
.
.
| constructor-nameₙ : constructor-typeₙ</code></pre>
<p>For the natural numbers, it is possible to convince Lean to use the familiar name <code>ℕ</code> by declaring
notation for it as follows:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">notation</span></span><span class="alectryon-token"> <span class="s2">&quot;ℕ&quot;</span> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">notation</span></span><span class="alectryon-token"> <span class="s2">&quot;ℤ &quot;</span> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Int</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Int</span><span class="alectryon-token"></span></span></pre>
<p>You can also use literals <code>0, 1, 2, . . .</code> and Lean will be able to infer that they are of type <code>Nat</code>
when they are used in that context.</p>
<p>We can inspect an earlier definition at any point in Lean by using the <code>#print</code> command. For example,
<code>#print Nat</code> within the <code>my_nat</code> namespace displays the following information:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="TypeDefinitions-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="TypeDefinitions-lean-chk0"><span class="alectryon-token"><span class="k">#print</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kd">inductive</span> my_nat.Nat : <span class="kt">Type</span>
number of <span class="kd">parameters</span>: <span class="mi">0</span>
constructors:
my_nat.Nat.zero : my_nat.Nat
my_nat.Nat.succ : my_nat.Nat <span class="bp">→</span> my_nat.Nat</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>my_nat.Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>my_nat.Nat</span><span class="alectryon-token"></span></span></pre>
<pre><code>inductive my_nat.Nat : Type
number of parameters: 0
constructors:
my_nat.Nat.zero : my_nat.Nat
my_nat.Nat.succ : my_nat.Nat → my_nat.Nat
</code></pre>
<p>The focus on natural numbers is one of the many features of this guide that reveal a bias towards
computer science. Number theorists would be more interested in the integers <code>ℤ</code> and the rational
numbers <code>ℚ</code>; analysts would want to work with the real numbers <code>ℝ</code> and the complex numbers <code>ℂ</code>. But the
natural numbers are ubiquitous in computer science and enjoy a very simple definition as an
inductive type. They can also be used to build other types, as we will see in Chapter 13.</p>
<h3 id="arithmetic-expressions"><a class="header" href="#arithmetic-expressions">Arithmetic Expressions</a></h3>
<p>If we were to specify a calculator program or a programming language, we would
likely need to define a type to represent arithmetic expressions. The next example
shows how this could be done in Lean:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token">  </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>num</var><b>: </b><span>ℤ → aexp</span></span></div></blockquote></div></small></div>num</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Int</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Int</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>String → aexp</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>aexp → aexp → aexp</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sub</var><b>: </b><span>aexp → aexp → aexp</span></span></div></blockquote></div></small></div>sub</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>aexp → aexp → aexp</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>div</var><b>: </b><span>aexp → aexp → aexp</span></span></div></blockquote></div></small></div>div</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">aexp</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TypeDefinitions-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="TypeDefinitions-lean-chk1"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">aexp.num <span class="mi">1</span> : aexp</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp.num</var><b>: </b><span>ℤ → aexp</span></span></div></blockquote></div></small></div>aexp.num</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">     <span class="c1">-- aexp.num 1 : aexp</span></span></span></pre>
<p>Mathematically, this definition is equivalent to defining the type <code>aexp</code> inductively
by the following formation rules:</p>
<ol>
<li>For every integer <code>i</code>, we have that <code>aexp.num i</code> is an <code>aexp</code> value.</li>
<li>For every character string <code>x</code>, we have that <code>aexp.var x</code> is an <code>aexp</code> value.</li>
<li>If <code>e1</code> and <code>e2</code> are <code>aexp</code> values, then so are <code>aexp.add e1 e2</code>, <code>aexp.sub e1 e2</code>,
<code>aexp.mul e1 e2</code>, and <code>aexp.div e1 e2</code>.</li>
</ol>
<p>The above definition is exhaustive. The only possible values for <code>aexp</code> are those built using
formation rules 1 to 3. Moreover, <code>aexp</code> values built using different formation rules are distinct.
These two properties of inductive types are captured by the motto “No junk, no confusion,” due to
Joseph Goguen.</p>
<h3 id="comparison-with-java"><a class="header" href="#comparison-with-java">Comparison with Java</a></h3>
<p>It may be instructive to compare the concise Lean specification of <code>aexp</code> above with a Java program
that achieves the same. The program consists of one interface and six classes that implement it,
corresponding to the <code>aexp</code> type and its six constructors:</p>
<pre><code class="language-java">public interface AExp { }
public class Num implements AExp {
  public int num;
  public Num(int num) { this.num = num; }
}
public class Var implements AExp {
  public String var;
  public Var(String var) { this.var = var; }
}
public class Add implements AExp {
  public AExp left;
  public AExp right;
  public Add(AExp left, AExp right)
  { this.left = left; this.right = right; }
}
public class Sub implements AExp {
  public AExp left;
  public AExp right;
  public Sub(AExp left, AExp right)
  { this.left = left; this.right = right; }
}
public class Mul implements AExp {
  public AExp left;
  public AExp right;
  public Mul(AExp left, AExp right)
  { this.left = left; this.right = right; }
}
public class Div implements AExp {
  public AExp left;
  public AExp right;
  public Div(AExp left, AExp right)
  { this.left = left; this.right = right; }
}
</code></pre>
<h3 id="comparison-with-c"><a class="header" href="#comparison-with-c">Comparison with C</a></h3>
<p>In C, the natural counterpart of an inductive type is a tagged union. The type
declarations would be as follows:</p>
<pre><code class="language-C">#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;
enum AExpKind {
  AET_NUM, AET_VAR, AET_ADD, AET_SUB, AET_MUL, AET_DIV
};
struct aexp;
struct aexp_num {
  int num;
};
struct aexp_var {
  char var[1024];
};
struct aexp_binop {
  struct aexp *left;
  struct aexp *right;
};
struct aexp {
  enum AExpKind kind;
  union {
    struct aexp_num anum;
    struct aexp_var avar;
    struct aexp_binop abinop;
  } data;
};
</code></pre>
<p>Corresponding to each constructor in Lean, we would need to write a function
to allocate an <code>aexp</code> object of the right size in memory. Here is the definition of the
function corresponding to the first constructor, <code>aexp.num</code>:</p>
<pre><code class="language-C">struct aexp *create_num(int num)
{
  struct aexp *res = malloc(offsetof(struct aexp, data) +
  sizeof(struct aexp_num));
  res-&gt;kind = AET_NUM;
  res-&gt;data.anum.num = num;
  return res;
}
</code></pre>
<p>The subtle pointer arithmetic for the <code>malloc</code> call is needed to allocate exactly the
right amount of memory.</p>
<h3 id="lists"><a class="header" href="#lists">Lists</a></h3>
<p>The next type we consider is that of finite lists (shown here in a temporary namespace
so it doesn't conflict with the same built-in type):</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">namespace</span></span><span class="alectryon-token"> my_list

</span><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">List</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type} → List α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">List</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type} → α → List α → List α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>head</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">head</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tail</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">tail</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">List</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">List</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">end</span></span><span class="alectryon-token"> my_list</span></span></pre>
<p>The type is <em>polymorphic</em>: It is parameterized by a type α, which we can instantiate with concrete
types. For example, <code>List ℤ</code>  is the type of lists over integers, and <code>List (List ℝ)</code> is the type of
lists of lists of real numbers. The type constructor <code>List</code> takes a type as argument and returns a
type. Polymorphism is related to generics (in Java) and templates (in C++). The general idea in all
cases is to have parameterized types.</p>
<p>The following commands display the constructors’ types:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="TypeDefinitions-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="TypeDefinitions-lean-chk2"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[] : List <span class="bp">?</span>m.4805</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.nil</var><b>: </b><span>{α : Type u_1} → List α</span></span></div></blockquote></div></small></div>List.nil</span><span class="alectryon-token">       <span class="c1">-- [] : List ?m.6639</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TypeDefinitions-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="TypeDefinitions-lean-chk3"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">List.cons : <span class="bp">?</span>m.4807 <span class="bp">→</span> List <span class="bp">?</span>m.4807 <span class="bp">→</span> List <span class="bp">?</span>m.4807</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.cons</var><b>: </b><span>{α : Type u_1} → α → List α → List α</span></span></div></blockquote></div></small></div>List.cons</span><span class="alectryon-token">      <span class="c1">-- List.cons : ?m.6641 → List ?m.6641 → List ?m.6641</span></span></span></pre>
<p>Informally:</p>
<ul>
<li>The <code>nil</code> constructor takes a type α as argument and produces a result of type
<code>List α</code>. The type was not defined here so you see <code>?m.6639</code> which represents
an unresolved metavariable in the Lean compilation.</li>
<li>The <code>cons</code> constructor takes an element (the <em>head</em>) of some arbitrary type
<code>?m.6641</code> as argument and a list over <code>?m.6641</code> (the tail) and produces a result of
type list <code>?m.6641</code>. Unlike for nil, there is no need to pass a type argument to
cons—the type is inferred from the first argument. If we want to pass the type
argument explicitly, we need to write an at sign (@) in front of the constant:
<code>@List.cons</code>.</li>
</ul>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="TypeDefinitions-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="TypeDefinitions-lean-chk4"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">List.cons : ℕ <span class="bp">→</span> List ℕ <span class="bp">→</span> List ℕ</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.cons</var><b>: </b><span>{α : Type} → α → List α → List α</span></span></div></blockquote></div></small></div>List.cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">   <span class="c1">-- List.cons : ℕ → List ℕ → List ℕ</span></span></span></pre>
<p>Even if we try to restrict ourselves to a fragment of Lean’s language, Lean often
exposes us to more advanced constructs in the output, such as <code>?m.6641</code> above, <code>Sort u</code>,
or <code>Type 1</code>. Our advice is to adopt a sporty attitude: Do not worry if you do not
always understand everything the first time. Use your common sense and your
imagination. And, above all, do not hesitate to ask.</p>
<p>Lean’s built-in lists offer syntactic sugar for writing lists:</p>
<ul>
<li><code>[]</code> for <code>List.nil</code></li>
<li><code>x :: xs</code> for <code>List.cons x xs</code></li>
<li><code>[x₁, . . ., xₙ]</code> for <code>x₁ :: . . . :: xₙ :: []</code></li>
</ul>
<p>The <code>::</code> operator, like all other binary operators, binds less tightly than function
application. Thus, <code>f x :: reverse ys</code> is parsed as <code>(f x) :: (reverse ys)</code>. It is good
practice to avoid needless parentheses. They can quickly impair readability. In
addition, it is important to put spaces around infix operators, to suggest the right
precedence; it is all too easy to misread <code>f x::reverse ys</code> as <code>f (x::reverse) ys</code> otherwise.</p>
<p>Functional programmers often use plural names such as <code>xs</code>, <code>ys</code>, <code>zs</code> for lists
(or more generally collections). A list contains many elements, so a plural form is natural.
A list of <code>cat</code> objects might be called <code>cats</code>; a list of list of <code>cat</code> objects, <code>catss</code>.
When a nonempty list is presented as a head and a tail, we usually write, say, <code>x :: xs</code> or <code>cat :: cats</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Basics.TypeDefinitions</span></span></pre>
<h2 id="function-definitions"><a class="header" href="#function-definitions">Function Definitions</a></h2>
<p>If all we want is to declare a function, we can use the <code>def</code> command.
Going back to the arithmetic expression example from <a href="Basics/./TypeDefinitions.lean.html">Typoe Definitions</a>, if we wanted to
implement an eval function in Java, we would probably add it as part of AExp’s
interface and implement it in each subclass. For Add, Sub, Mul, and Div, we would
recursively call eval on the left and right objects.</p>
<p>In Lean, the syntax is very compact. We define a single function and use pattern
matching to distinguish the six cases:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>(String → ℤ ) → aexp → ℤ</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>String → ℤ</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Int</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Int</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>aexp</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Int</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Int</span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp.num</var><b>: </b><span>ℤ → aexp</span></span></div></blockquote></div></small></div>aexp.num</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp.var</var><b>: </b><span>String → aexp</span></span></div></blockquote></div></small></div>aexp.var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>String → ℤ</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp.add</var><b>: </b><span>aexp → aexp → aexp</span></span></div></blockquote></div></small></div>aexp.add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₁</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₂</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₂</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>(String → ℤ ) → aexp → ℤ</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>String → ℤ</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₁</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₁</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>(String → ℤ ) → aexp → ℤ</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>String → ℤ</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₂</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₂</span></span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp.sub</var><b>: </b><span>aexp → aexp → aexp</span></span></div></blockquote></div></small></div>aexp.sub</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₁</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₂</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₂</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>(String → ℤ ) → aexp → ℤ</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>String → ℤ</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₁</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₁</span></span><span class="alectryon-token"> <span class="bp">-</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>(String → ℤ ) → aexp → ℤ</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>String → ℤ</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₂</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₂</span></span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp.mul</var><b>: </b><span>aexp → aexp → aexp</span></span></div></blockquote></div></small></div>aexp.mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₁</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₂</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₂</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>(String → ℤ ) → aexp → ℤ</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>String → ℤ</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₁</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₁</span></span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>(String → ℤ ) → aexp → ℤ</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>String → ℤ</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₂</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₂</span></span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp.div</var><b>: </b><span>aexp → aexp → aexp</span></span></div></blockquote></div></small></div>aexp.div</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₁</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₂</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₂</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>(String → ℤ ) → aexp → ℤ</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>String → ℤ</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₁</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₁</span></span><span class="alectryon-token"> <span class="bp">/</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>(String → ℤ ) → aexp → ℤ</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>String → ℤ</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e₂</var><b>: </b><span>aexp</span></span></div></blockquote></div></small></div><span class="nv">e₂</span></span><span class="alectryon-token"></span></span></pre>
<p>The keyword <code>def</code> introduces the definition. The general format of definitions by
pattern matching is:</p>
<pre><code class="language-lean">def name (params₁ : type₁) . . . (paramsₘ : typeₘ) : type
| patterns₁ := result₁
.
.
.
| patternsₙ := resultₙ</code></pre>
<p>The parentheses ( ) around the parameters can also be curly braces { } if we want
to make them implicit arguments. The parameters cannot be subjected to pattern
matching, only the remaining arguments (e.g., the <code>aexp</code> argument of <code>eval</code>).</p>
<p>Patterns may contain variables, which are then visible in the corresponding
right-hand side, as well as constructors. For example, in the second case in eval’s
definition, the variable <code>x</code> can be used in the right-hand side <code>env x</code>.</p>
<p>Some definitions do not need pattern matching. For these, the syntax is simply</p>
<pre><code class="language-lean">def name (params₁ : type₁) . . . (paramsₘ : typeₘ) : type :=
  result</code></pre>
<p>We can have pattern matching without recursion (e.g., in the <code>aexp.num</code> and <code>aexp.var</code> cases above),
and we can have recursion without pattern matching.</p>
<p>The basic arithmetic operations on natural numbers, such as addition, can be
defined by recursion:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div><span class="nv">add</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.zero</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div>Nat.zero</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">, (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>Nat.succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>Nat.succ</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div><span class="nv">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">)</span></span></pre>
<p>We pattern-match on two arguments at the same time, distinguishing the case where the second
argument is zero and the case where it is nonzero. Each recursive call to add peels off one <code>Nat.succ</code>
constructor from the second argument. Instead of <code>Nat.zero</code> and <code>Nat.succ n</code>, Lean also allows us to
write <code>0</code> and <code>n + 1</code> as syntactic sugar.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add₂</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div><span class="nv">add₂</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">, (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">+</span> <span class="mi">1</span>) <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"></span></span></pre>
<p>We can evaluate the result of applying add to numbers using <code>#eval</code> or <code>#reduce</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">9</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>7</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">7</span></span><span class="alectryon-token">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chk1"><span class="alectryon-token"><span class="k">#reduce</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">9</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>7</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">7</span></span><span class="alectryon-token"></span></span></pre>
<p>Both commands print 9, as expected. <code>#eval</code> employs an optimized interpreter,
whereas <code>#reduce</code> uses Lean’s inference kernel, which is less effcient.</p>
<p>Perhaps you are worried about division by zero in the definition of eval above.
Let us see what <code>#eval</code> has to say about it:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chk2"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">0</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>(String → ℤ ) → aexp → ℤ</span></span></div></blockquote></div></small></div>eval</span><span class="alectryon-token"> (<span class="bp">λ</span> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chk3"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">x</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>x<span class="bp">`</span> [linter.unusedVariables]</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>7</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="mi">7</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp.div</var><b>: </b><span>aexp → aexp → aexp</span></span></div></blockquote></div></small></div>aexp.div</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp.var</var><b>: </b><span>String → aexp</span></span></div></blockquote></div></small></div>aexp.var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;x&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;x&quot;</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>aexp.num</var><b>: </b><span>ℤ → aexp</span></span></div></blockquote></div></small></div>aexp.num</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">))</span></span></pre>
<p>The output is 0. In Lean, division is conveniently defined as a total function that
returns zero when the denominator is zero. For a lucid explanation of why this is
not dangerous, see <a href="https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/">Buzzard’s blog</a>.</p>
<p>It is good practice to provide a few tests each time we define a function, to
ensure that it behaves as expected. You can even leave the <code>#eval</code> or <code>#reduce</code>
calls in your Lean files as documentation.</p>
<p>The definition of multiplication is similar to that of addition and we can reuse our
<code>add</code> function here:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div><span class="nv">mul</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
<span class="bp">|</span> _, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.zero</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div>Nat.zero</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.zero</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div>Nat.zero</span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">, (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>Nat.succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div><span class="nv">mul</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">)</span></span></pre>
<p>The underscore (<code>_</code>) stands for an unused variable. We could have put a name (e.g., <code>m</code>),
but <code>_</code> documents our intentions better.</p>
<p>The #eval command below prints 14, as expected:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chk4"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">14</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>7</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">7</span></span><span class="alectryon-token"></span></span></pre>
<p>The power operation (“<em>m</em> to the power of <em>n</em>”) can be defined in various ways.
Our first proposal is structurally identical to the definition of multiplication:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>power</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div><span class="nv">power</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
<span class="bp">|</span> _, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.zero</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div>Nat.zero</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">, (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>Nat.succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>power</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div><span class="nv">power</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">)</span></span></pre>
<p>Since the first argument, <code>m</code>, remains unchanged in the recursive call, <code>power m n</code>, we
can factor it out and put it next to the function’s name, as a parameter, before the
colon introducing the type of the function (excluding the parameter <code>m</code>):</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>power₂</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div><span class="nv">power₂</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.zero</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div>Nat.zero</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>Nat.succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>power₂</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div><span class="nv">power₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chk5"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">128</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>power₂</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>power₂</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>7</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">7</span></span><span class="alectryon-token">    <span class="c1">-- 128</span></span></span></pre>
<p>Yet another definition is possible by first introducing a general-purpose iterator
that applies a function recursively over the Nat values:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iter</var><b>: </b><span>{α : Sort u_1} → α → (α → α) → ℕ → α</span></span></div></blockquote></div></small></div><span class="nv">iter</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">z</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.zero</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div>Nat.zero</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">z</span></span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>Nat.succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iter</var><b>: </b><span>{α : Sort u_1} → α → (α → α) → ℕ → α</span></span></div></blockquote></div></small></div><span class="nv">iter</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">z</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>power₃</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div><span class="nv">power₃</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iter</var><b>: </b><span>{α : Type} → α → (α → α) → ℕ → α</span></span></div></blockquote></div></small></div>iter</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> (<span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chk6"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">128</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>power₃</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>power₃</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>7</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">7</span></span><span class="alectryon-token">    <span class="c1">-- 128</span></span></span></pre>
<p>Notice that the <code>power₃</code> is not recursive since the recursion is done by <code>iter</code>.</p>
<p>Recursive functions on lists can be defined in a similar way:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append</var><b>: </b><span>(α : Type) → List α → List α → List α</span></span></div></blockquote></div></small></div><span class="nv">append</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">): </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.nil</var><b>: </b><span>{α : Type ?u.2354} → List α</span></span></div></blockquote></div></small></div>List.nil</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.nil</var><b>: </b><span>{α : Type ?u.2373} → List α</span></span></div></blockquote></div></small></div>List.nil</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.cons</var><b>: </b><span>{α : Type ?u.2390} → α → List α → List α</span></span></div></blockquote></div></small></div>List.cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">), </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.cons</var><b>: </b><span>{α : Type} → α → List α → List α</span></span></div></blockquote></div></small></div>List.cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append</var><b>: </b><span>(α : Type) → List α → List α → List α</span></span></div></blockquote></div></small></div><span class="nv">append</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chk7"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">append : (α : <span class="kt">Type</span>) <span class="bp">→</span> List α <span class="bp">→</span> List α <span class="bp">→</span> List α</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append</var><b>: </b><span>(α : Type) → List α → List α → List α</span></span></div></blockquote></div></small></div>append</span><span class="alectryon-token">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chk8"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">3</span>, <span class="mi">1</span>, <span class="mi">4</span>, <span class="mi">1</span>, <span class="mi">5</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append</var><b>: </b><span>(α : Type) → List α → List α → List α</span></span></div></blockquote></div></small></div>append</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">]   <span class="c1">-- [3, 1, 4, 1, 5]</span></span></span></pre>
<p>This append function takes three arguments: a type <code>α</code> and two lists of type <code>List α</code>
and it produces a resulting list of type <code>List α</code>.
By passing the placeholder <code>_</code>, we leave it to Lean to infer the type α from the type
of the other two arguments.</p>
<p>To make the type argument α implicit, we can put it in curly braces <code>{ }</code></p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append₂</var><b>: </b><span>{α : Type} → List α → List α → List α</span></span></div></blockquote></div></small></div><span class="nv">append₂</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.nil</var><b>: </b><span>{α : Type ?u.2822} → List α</span></span></div></blockquote></div></small></div>List.nil</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.nil</var><b>: </b><span>{α : Type ?u.2841} → List α</span></span></div></blockquote></div></small></div>List.nil</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.cons</var><b>: </b><span>{α : Type ?u.2858} → α → List α → List α</span></span></div></blockquote></div></small></div>List.cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">), </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.cons</var><b>: </b><span>{α : Type} → α → List α → List α</span></span></div></blockquote></div></small></div>List.cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append₂</var><b>: </b><span>{α : Type} → List α → List α → List α</span></span></div></blockquote></div></small></div><span class="nv">append₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chk9"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">append₂ : List <span class="bp">?</span>m.3165 <span class="bp">→</span> List <span class="bp">?</span>m.3165 <span class="bp">→</span> List <span class="bp">?</span>m.3165</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append₂</var><b>: </b><span>{α : Type} → List α → List α → List α</span></span></div></blockquote></div></small></div>append₂</span><span class="alectryon-token">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chka"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">3</span>, <span class="mi">1</span>, <span class="mi">4</span>, <span class="mi">1</span>, <span class="mi">5</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append₂</var><b>: </b><span>{α : Type} → List α → List α → List α</span></span></div></blockquote></div></small></div>append₂</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">]    <span class="c1">-- [3, 1, 4, 1, 5]</span></span></span></pre>
<p>The at sign (<code>@</code>) can be used to make the implicit arguments explicit.
This is useful for debugging and occasionally necessary to guide Lean’s parser:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chkb"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="bp">@</span>append₂ : {α : <span class="kt">Type</span>} <span class="bp">→</span> List α <span class="bp">→</span> List α <span class="bp">→</span> List α</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append₂</var><b>: </b><span>{α : Type} → List α → List α → List α</span></span></div></blockquote></div></small></div>append₂</span><span class="alectryon-token">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chkc"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">3</span>, <span class="mi">1</span>, <span class="mi">4</span>, <span class="mi">1</span>, <span class="mi">5</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append₂</var><b>: </b><span>{α : Type} → List α → List α → List α</span></span></div></blockquote></div></small></div>append₂</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">]</span></span></pre>
<p>We can use syntactic sugar in the definition, both in the patterns on the left-hand sides of <code>=&gt;</code> and in the right-hand sides:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append₃</var><b>: </b><span>{α : Type} → List α → List α → List α</span></span></div></blockquote></div></small></div><span class="nv">append₃</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
<span class="bp">|</span> [], </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">), </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append₃</var><b>: </b><span>{α : Type} → List α → List α → List α</span></span></div></blockquote></div></small></div><span class="nv">append₃</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ys</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">ys</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chkd"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">3</span>, <span class="mi">1</span>, <span class="mi">4</span>, <span class="mi">1</span>, <span class="mi">5</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append₃</var><b>: </b><span>{α : Type} → List α → List α → List α</span></span></div></blockquote></div></small></div>append₃</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">]    <span class="c1">-- [3, 1, 4, 1, 5]</span></span></span></pre>
<p>In Lean’s standard library, the append function has an infix operator called <code>++</code>.
We can use it to define a function that reverses a list:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse</var><b>: </b><span>{α : Type} → List α → List α</span></span></div></blockquote></div></small></div><span class="nv">reverse</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
<span class="bp">|</span> [] <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse</var><b>: </b><span>{α : Type} → List α → List α</span></span></div></blockquote></div></small></div><span class="nv">reverse</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">]

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="FunctionDefinitions-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="FunctionDefinitions-lean-chke"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">3</span>, <span class="mi">2</span>, <span class="mi">1</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse</var><b>: </b><span>{α : Type} → List α → List α</span></span></div></blockquote></div></small></div>reverse</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">]   <span class="c1">-- [3, 2, 1]</span></span></span></pre><div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Basics.FunctionDefinitions</span></span></pre>
<h2 id="theorem-statements"><a class="header" href="#theorem-statements">Theorem Statements</a></h2>
<p>What makes Lean a proof assistant and not only a programming language is that we can state theorems
about the types and constants we define and prove that they hold. We will use the terms theorem,
lemma, corollary, fact, property, and true statement more or less interchangeably. Similarly,
propositions, logical formulas, and statements will all mean the same.</p>
<p>In Lean, propositions are simply terms of type <code>Prop</code>. This stands in contrast with most
descriptions of first-order logic, where terms and formulas are separate syntactic entities. A
proposition that can be proved is called a theorem (or lemma, corollary, etc.); otherwise it is a
nontheorem or false statement. Mathematicians sometimes use the term “proposition” as a synonym for
theorem (e.g., “Proposition 3.14”), but in formal logic propositions can also be false. Here are
examples of true statements that can be made about the addition, multiplication, and list reversal
operations defined in <a href="Basics/./FunctionDefinitions.lean.html">Function Definitions</a>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TheoremStatements-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="TheoremStatements-lean-chk0"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add_comm</var><b>: </b><span>∀ (m n : ℕ), add m n = add n m</span></span></div></blockquote></div></small></div><span class="nv">add_comm</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: declaration uses <span class="bp">&#39;</span><span class="gr">sorry</span><span class="bp">&#39;</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sorry</var><b>: </b><span>add m n = add n m</span></span></div></blockquote></div></small></div><span class="gr">sorry</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TheoremStatements-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="TheoremStatements-lean-chk1"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add_assoc</var><b>: </b><span>∀ (l m n : ℕ), add (add l m) n = add l (add m n)</span></span></div></blockquote></div></small></div><span class="nv">add_assoc</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: declaration uses <span class="bp">&#39;</span><span class="gr">sorry</span><span class="bp">&#39;</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sorry</var><b>: </b><span>add (add l m) n = add l (add m n)</span></span></div></blockquote></div></small></div><span class="gr">sorry</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TheoremStatements-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="TheoremStatements-lean-chk2"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul_comm</var><b>: </b><span>∀ (m n : ℕ), mul m n = mul n m</span></span></div></blockquote></div></small></div><span class="nv">mul_comm</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: declaration uses <span class="bp">&#39;</span><span class="gr">sorry</span><span class="bp">&#39;</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sorry</var><b>: </b><span>mul m n = mul n m</span></span></div></blockquote></div></small></div><span class="gr">sorry</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TheoremStatements-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="TheoremStatements-lean-chk3"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul_assoc</var><b>: </b><span>∀ (l m n : ℕ), mul (mul l m) n = mul l (mul m n)</span></span></div></blockquote></div></small></div><span class="nv">mul_assoc</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: declaration uses <span class="bp">&#39;</span><span class="gr">sorry</span><span class="bp">&#39;</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sorry</var><b>: </b><span>mul (mul l m) n = mul l (mul m n)</span></span></div></blockquote></div></small></div><span class="gr">sorry</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TheoremStatements-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="TheoremStatements-lean-chk4"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul_add</var><b>: </b><span>∀ (l m n : ℕ), mul l (add m n) = add (mul l m) (mul l n)</span></span></div></blockquote></div></small></div><span class="nv">mul_add</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: declaration uses <span class="bp">&#39;</span><span class="gr">sorry</span><span class="bp">&#39;</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sorry</var><b>: </b><span>mul l (add m n) = add (mul l m) (mul l n)</span></span></div></blockquote></div></small></div><span class="gr">sorry</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TheoremStatements-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="TheoremStatements-lean-chk5"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse_reverse</var><b>: </b><span>∀ {α : Type} (xs : List α), reverse (reverse xs) = xs</span></span></div></blockquote></div></small></div><span class="nv">reverse_reverse</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: declaration uses <span class="bp">&#39;</span><span class="gr">sorry</span><span class="bp">&#39;</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse</var><b>: </b><span>{α : Type} → List α → List α</span></span></div></blockquote></div></small></div>reverse</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse</var><b>: </b><span>{α : Type} → List α → List α</span></span></div></blockquote></div></small></div>reverse</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sorry</var><b>: </b><span>reverse (reverse xs) = xs</span></span></div></blockquote></div></small></div><span class="gr">sorry</span></span><span class="alectryon-token"></span></span></pre>
<p>The general format is</p>
<pre><code class="language-lean">theorem name (params1 : type1) . . . (paramsm : typem) :
  statement :=
  proof</code></pre>
<p>The <code>:=</code> symbol separates the theorem’s statement and its proof. The syntax of theorem is very
similar to that of a <code>def</code> command without pattern matching, with <code>statement</code> instead of <code>type</code> and
<code>proof</code> instead of <code>result</code>. In the examples above, we put the marker <code>sorry</code> as a placeholder for
the actual proof. The marker is quite literally an apology to future readers and to Lean for the
absence of a proof. It is also a reason to <em>worry</em>, until we manage to eliminate it. In Chapters 2
and 3, we will see how to achieve this.</p>
<p>The intuitive semantic of a theorem command with a <code>sorry</code> proof is, “This proposition should be
provable, but I have not carried out the proof yet—sorry.” Sometimes, we want to express a related
idea, namely, “Let us assume this proposition holds.” Lean provides the axiom command for this,
which is often used in conjunction with constant(s). For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">axiom</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a_less_b</var><b>: </b><span>∀ (a b : ℤ ), a &lt; b</span></span></div></blockquote></div></small></div>a_less_b</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℤ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℤ</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>ℤ</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"></span></span></pre>
<p>Here we have no information about a and b beyond their type. The axiom specifies the desired
property about them. The general format of the command is</p>
<pre><code class="language-lean">axiom name (params₁ : type₁) . . . (paramsₘ : typeₘ) :
  statement</code></pre>
<p>Axioms are dangerous, because they rapidly can lead to an inconsistent logic, in which we can derive
false. For example, if we added a second axiom stating that <code>a = b</code>, we could easily derive <code>b &lt; b</code>,
from which we could derive <code>false</code> is true. The history of interactive theorem proving is paved with
inconsistent axioms. An anecdote among many: At the 2020 edition of the Certified Programs and
Proofs (CPP) conference, a submitted paper was rejected due to a flawed axiom, from which one of the
peer reviewers derived <code>false</code>. Therefore, we will generally avoid axioms, preferring the benign
combination of <code>def</code> and <code>theorem</code> to the more dangerous <code>axiom</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="summary-of-new-lean-constructs"><a class="header" href="#summary-of-new-lean-constructs">Summary of New Lean Constructs</a></h2>
<p>At the end of this and most other chapters, we include a brief summary of the constructs introduced
in the chapter. Some syntaxes have multiple meanings, which will be introduced gradually. We refer
to <a href="Basics/../bib.html#3">The Lean Reference Manual</a>, the <a href="Basics/../bib.html#1">Theorem Proving in Lean</a> tutorial, and
the <a href="https://leanprover-community.github.io/mathlib_docs/">mathlib documentation</a> for details.</p>
<p><strong>Diagnosis Commands</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td>#check</td><td>checks and prints type of a term</td></tr>
<tr><td>#eval</td><td>executes a term using an optimized interpreter</td></tr>
<tr><td>#print</td><td>prints the definition of a constant</td></tr>
<tr><td>#reduce</td><td>executes a term using Lean’s inference kernel</td></tr>
</tbody></table>
</div>
<p><strong>Declarations</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Declaration</th><th>Description</th></tr></thead><tbody>
<tr><td>axiom</td><td>states an axiom</td></tr>
<tr><td>def</td><td>defines a new constant</td></tr>
<tr><td>inductive</td><td>introduces a type and its constructors</td></tr>
<tr><td>theorem</td><td>states a theorem and its proof</td></tr>
<tr><td>namespace . . .</td><td>end collects declarations in a named scope</td></tr>
</tbody></table>
</div>
<p><strong>Proof Commands</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td>sorry</td><td>stands for a missing proof or definition</td></tr>
</tbody></table>
</div>
<p>TODO : need to review closely how I removed &quot;contants&quot; from this chapter,
since we are generally hiding that term in Lean 4.  I instead jumped straight
to &quot;def&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> BackwardProofs.TacticMode</span></span></pre>
<h1 id="backward-proofs"><a class="header" href="#backward-proofs">Backward Proofs</a></h1>
<p>In this chapter, we see how to prove Lean lemmas using tactics, and we review the most important
Lean tactics. A <em>tactic</em> is a procedure that operates on the goal— the proposition to prove—and
either fully proves it or produces new subgoals (or fails). When we state a lemma, the lemma
statement is the initial goal. A proof is complete once all (sub)goals have been eliminated using
suitable tactics. The tactics described here are documented in more detail in Chapter 5 of <a href="BackwardProofs/../bib.html#1">Theorem
Proving in Lean</a> and Chapter 6 of <a href="BackwardProofs/../bib.html">The Lean Reference Manual</a>. Tactics
are a backward proof mechanism. They start from the goal and work backwards towards the already
proved lemmas. Consider the lemmas <code>a, a → b</code>, and <code>b → c</code> and the goal <code>⊢ c</code>. An informal backward
proof is as follow:</p>
<ul>
<li>To prove <code>c</code>, by <code>b → c</code> it suffices to prove <code>b</code>.</li>
<li>To prove <code>b</code>, by <code>a → b</code> it suffices to prove <code>a</code>.</li>
<li>To prove <code>a</code>, we use <code>a</code>.</li>
</ul>
<p>The telltale sign of a backward proof is the phrase “it suffices to.” Notice how we
progress from one goal to another ( <code>⊢ c</code>, <code>⊢ b</code>, <code>⊢ a</code>) until no goal is lean to prove. By
contrast, a forward proof would start from the lemma a and progress, one theorem
at a time, towards the desired theorem <code>c</code>:</p>
<ul>
<li>From <code>a</code> and <code>a → b</code>, we have <code>b</code>.</li>
<li>From <code>b</code> and <code>b → c</code>, we have <code>c</code>, as desired.</li>
</ul>
<p>A forward proof only manipulates theorems, not goals. We will study forward
proofs more deeply in Chapter 3.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre><div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Mathlib.Tactic.Basic</span></span></pre>
<h2 id="tactic-mode"><a class="header" href="#tactic-mode">Tactic Mode</a></h2>
<p>In Chapter 1, whenever a proof was required, we simply put a <code>sorry</code> placeholder.
For a tactical proof, we will now write <code>by</code> to enter tactic mode. In this mode,
we can apply a sequence of tactics, separated by semicolons or new lines.</p>
<p>Tactics operate on the goal, which consists of the proposition <code>Q</code> that we want to
prove and of a local context <code>C</code>. The local context consists of variable declarations
of the form <code>c : τ</code> and hypotheses of the form <code>h : P</code>. We write <code>C ⊢ Q</code> to denote a
goal, where <code>C</code> is a list of variables and hypotheses and <code>Q</code> is the goal’s target.</p>
<p>To make things more concrete, consider the following Lean example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fst_of_two_props</var><b>: </b><span>∀ (a b : Prop), a → b → a</span></span></div></blockquote></div></small></div><span class="nv">fst_of_two_props</span></span><span class="alectryon-token"> :
  <span class="bp">∀</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∀</span> (a b : <span class="kt">Prop</span>), a <span class="bp">→</span> b <span class="bp">→</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chk1"><span class="alectryon-token"><span class="k">intros</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a <span class="bp">→</span> b <span class="bp">→</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chk2"><span class="alectryon-token"><span class="k">intros</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a <span class="bp">→</span> b <span class="bp">→</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chk3"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hb</var><b>: </b><span>b</span></span></div></blockquote></div></small></div><span class="nv">hb</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>hb<span class="bp">`</span> [linter.unusedVariables]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chk4"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Note that the implication arrow <code>→</code> is right-associative; this means that <code>a → b → a</code>
is the same as <code>a → (b → a)</code>. Intuitively speaking, it has the meaning “<code>a</code> implies
that <code>b</code> implies <code>a</code>,” or equivalently “<code>a</code> and <code>b</code> imply <code>a</code>.” In the example, three tactics
are invoked, each on its own line. Let us trace their behavior:</p>
<ol>
<li>
<p>Initially, the goal is simply the lemma statement:</p>
<pre><code class="language-lean">⊢ ∀ a b : Prop, a → b → a</code></pre>
</li>
<li>
<p>The <code>intros a b</code> tactic tells Lean to fix two free variables, <code>a</code> and <code>b</code>,
corresponding to the two bound variables of the same names. Offen, we name the free
variables after the bound variables. The tactic mimics how mathematicians
work on paper: To prove a ∀-quantified proposition, it suffices to prove it for
some arbitrary but fixed value of the bound variable. The goal becomes</p>
<pre><code class="language-lean">a b : Prop ⊢ a → b → a</code></pre>
</li>
<li>
<p>The <code>intros ha hb</code> tactic tells Lean to move the assumptions <code>a</code> and <code>b</code> to the
local context and to call these hypotheses <code>ha</code> and <code>hb</code>. Indeed, to prove an
implication, it suffices to take its left-hand side as hypothesis and prove its
right-hand side. The goal becomes</p>
<pre><code class="language-lean">a b : Prop, ha : a, hb : b ⊢ a</code></pre>
</li>
<li>
<p>The <code>apply ha</code> tactic tells Lean to match the hypothesis <code>a</code>, called <code>ha</code>, against
the goal <code>⊢ a</code>. Since <code>a</code> is syntactically equal to <code>a</code>, we have a match, and this
completes the proof.</p>
</li>
</ol>
<p>Informally, in a style reminiscent of pen-and-paper mathematics, we could
write the proof as follows:</p>
<ul>
<li>Let <code>a</code> and <code>b</code> be propositions.</li>
<li>Assume <code>(ha) a</code> and <code>(hb) b</code> are true.</li>
<li>To prove <code>a</code>, we use hypothesis <code>ha</code>.</li>
</ul>
<p>(Mathematicians would probably use numeric tags such as (1) and (2) for the hypotheses
instead of informative names.)</p>
<p>Going back to the Lean proof, we can avoid the <code>intros</code> invocations by declaring
the variables and hypotheses as parameters of the lemma, as follows:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fst_of_two_props₂</var><b>: </b><span>∀ (a b : Prop), a → b → a</span></span></div></blockquote></div></small></div><span class="nv">fst_of_two_props₂</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">) (</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chk5"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hb</var><b>: </b><span>b</span></span></div></blockquote></div></small></div><span class="nv">hb</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>hb<span class="bp">`</span> [linter.unusedVariables]</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chk6"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chk7"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Here is an example with multiple <code>apply</code>s in sequence:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>prop_comp</var><b>: </b><span>∀ (a b c : Prop), (a → b) → (b → c) → a → c</span></span></div></blockquote></div></small></div><span class="nv">prop_comp</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hab</var><b>: </b><span>a → b</span></span></div></blockquote></div></small></div><span class="nv">hab</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hbc</var><b>: </b><span>b → c</span></span></div></blockquote></div></small></div><span class="nv">hbc</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chk8"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">→</span> b</span></span></span><br><span><var>hbc</var><span class="hyp-type"><b>: </b><span>b <span class="bp">→</span> c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a <span class="bp">→</span> c</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chk9"><span class="alectryon-token"><span class="k">intro</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">→</span> b</span></span></span><br><span><var>hbc</var><span class="hyp-type"><b>: </b><span>b <span class="bp">→</span> c</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">c</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chka"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hbc</var><b>: </b><span>b → c</span></span></div></blockquote></div></small></div><span class="nv">hbc</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">→</span> b</span></span></span><br><span><var>hbc</var><span class="hyp-type"><b>: </b><span>b <span class="bp">→</span> c</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chkb"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hab</var><b>: </b><span>a → b</span></span></div></blockquote></div></small></div><span class="nv">hab</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">→</span> b</span></span></span><br><span><var>hbc</var><span class="hyp-type"><b>: </b><span>b <span class="bp">→</span> c</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="TacticMode-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="TacticMode-lean-chkc"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Putting on our mathematician’s hat, we can verbalize the last proof as follows:</p>
<ul>
<li>Assume <code>(ha) a</code> is true.</li>
<li>To prove <code>c</code>, by hypothesis <code>hbc</code> it suffices to prove <code>b</code>.</li>
<li>To prove <code>b</code>, by hypothesis <code>hab</code> it suffices to prove <code>a</code>.</li>
<li>To prove <code>a</code>, we use hypothesis <code>ha</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Mathlib.Init.Data.Nat.Basic
<span class="kn">import</span> Mathlib.Init.Data.Int.Basic
<span class="kn">import</span> Mathlib.Tactic.Basic</span></span></pre>
<h2 id="basic-tactics"><a class="header" href="#basic-tactics">Basic Tactics</a></h2>
<p>We already saw the <code>intros</code> and <code>apply</code> tactics. These are the staples of tactical
proofs. Other basic tactics include <code>rfl</code>, <code>exact</code>, <code>assumption</code>, and <code>cc</code>. These tactics
can go a long way, if we are patient enough to carry out the reasoning using them,
without appealing to stronger proof automation. They can also be used to solve
various logic puzzles.</p>
<p>Below, the square brackets [] enclose optional syntax</p>
<p><strong>intro(s)</strong></p>
<pre><code>    intro [ name ]
    intros [ name₁ ... nameₙ ]
</code></pre>
<p>The <code>intro</code> tactic moves the leading ∀-quantified variable or the leading assumption <code>a →</code> from the
goal’s target to the local context. The tactic takes as an optional argument the name to give to the
variable or to the assumption in the context, overriding the default name. The plural variant intros
can be used to move several variables or assumptions at once.</p>
<p><strong>rfl</strong></p>
<p>The <code>rfl</code> tactic proves goals of the form <code>⊢ l = r</code>, where the two sides <code>l</code> and <code>r</code> are
syntactically equal up to computation. Computation means expansion of definitions, reduction of an
application of a λ-expression to an argument, and more.</p>
<p>These <em>conversions</em> have traditional names. The main conversions are listed below together with
examples, in a global context containing <code>def double (n : ℕ) : ℕ := n + n</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>effect</th></tr></thead><tbody>
<tr><td>α-conversion</td><td><code>(λx, f x) = (λy, f y)</code></td></tr>
<tr><td>β-conversion</td><td><code>(λx, f x) a = f a</code></td></tr>
<tr><td>δ-conversion</td><td><code>double 5 = 5 + 5</code></td></tr>
<tr><td>ζ-conversion</td><td><code>(let n : N := 2 in n + n) = 4</code></td></tr>
<tr><td>η-conversion</td><td><code>(λx, f x) = f</code></td></tr>
<tr><td>ι-conversion</td><td><code>prod.fst (a, b) = a</code></td></tr>
</tbody></table>
</div>
<p>Applying a conversion repeatedly as left-to-right rewrite rules is called _reduction); applying it
once in reverse is called <em>expansion</em>. Since much of Lean’s machinery treats terms that are
syntactically equal up to computation uniformly, it usually makes sense to tell Lean’s
pretty-printer to aggressively β-reduce its output. This is what the the command</p>
<pre><code>set_option pp.beta true   -- BUGBUG: https://github.com/leanprover/lean4/issues/715
</code></pre>
<p>near the top of the files accompanying this guide achieves.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α_example</var><b>: </b><span>∀ {α β : Type} (f : α → β), (fun x =&gt; f x) = fun y =&gt; f y</span></span></div></blockquote></div></small></div><span class="nv">α_example</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :
  (<span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) <span class="bp">=</span> (<span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">) :=
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α, β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x <span class="bp">=&gt;</span> f x) <span class="bp">=</span> <span class="k">fun</span> y <span class="bp">=&gt;</span> f y</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
   </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chk1"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α_example₂</var><b>: </b><span>∀ {α β : Type} (f : α → β), (fun x =&gt; f x) = fun y =&gt; f y</span></span></div></blockquote></div></small></div><span class="nv">α_example₂</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :
  (<span class="bp">λ</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) <span class="bp">=</span> (<span class="bp">λ</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">) :=
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chk2"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α, β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x <span class="bp">=&gt;</span> f x) <span class="bp">=</span> <span class="k">fun</span> y <span class="bp">=&gt;</span> f y</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chk3"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β_example</var><b>: </b><span>∀ {α β : Type} (f : α → β) (a : α), (fun x =&gt; f x) a = f a</span></span></div></blockquote></div></small></div><span class="nv">β_example</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) :
  (<span class="bp">λ</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :=
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chk4"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α, β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> β</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x <span class="bp">=&gt;</span> f x) a <span class="bp">=</span> f a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chk5"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div><span class="nv">double</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℕ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℕ</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℕ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℕ</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>δ_example</var><b>: </b><span>double 5 = 5 + 5</span></span></div></blockquote></div></small></div><span class="nv">δ_example</span></span><span class="alectryon-token"> :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> :=
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chk6"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">double <span class="mi">5</span> <span class="bp">=</span> <span class="mi">5</span> <span class="bp">+</span> <span class="mi">5</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chk7"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ζ_example</var><b>: </b><span>(let n := 2;
  n + n) =
  4</span></span></div></blockquote></div></small></div><span class="nv">ζ_example</span></span><span class="alectryon-token"> :
  (</span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℕ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℕ</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"><span class="bp">;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token"> :=
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chk8"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">let</span> n := <span class="mi">2</span><span class="bp">;</span>
  n <span class="bp">+</span> n) <span class="bp">=</span>
  <span class="mi">4</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chk9"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>η_example</var><b>: </b><span>∀ {α β : Type} (f : α → β), (fun x =&gt; f x) = f</span></span></div></blockquote></div></small></div><span class="nv">η_example</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :
  (<span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> :=
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chka"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α, β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x <span class="bp">=&gt;</span> f x) <span class="bp">=</span> f</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chkb"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ι_example</var><b>: </b><span>∀ {α β : Type} (a : α) (b : β), (a, b).fst = a</span></span></div></blockquote></div></small></div><span class="nv">ι_example</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prod.fst</var><b>: </b><span>{α β : Type} → α × β → α</span></span></div></blockquote></div></small></div>Prod.fst</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :=
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chkc"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α, β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a, b)<span class="bp">.</span>fst <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicTactics-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicTactics-lean-chkd"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p><strong>apply</strong></p>
<pre><code>    apply lemma-or-hypothesis
</code></pre>
<p>The <code>apply</code> tactic matches the goal’s target with the conclusion of the specified lemma or
hypothesis and adds the lemma or hypothesis’s assumptions as new goals. The matching is performed up
to computation.</p>
<p>We must invoke apply with care, because it can transform a provable goal into
an unprovable subgoal. For example, if the goal is <code>⊢ 2 + 2 = 4</code> and we apply the
lemma <code>false → ?a</code>, the variable <code>?a</code> is matched against <code>2 + 2 = 4</code>, and we end up
with the unprovable subgoal <code>⊢ false</code>. We say that <code>apply</code> is unsafe. In contrast,
<code>intro</code> always preserves provability and is therefore safe.</p>
<p><strong>exact</strong>
<code>exact lemma-or-hypothesis
   </code></p>
<p>The <code>exact</code> tactic matches the goal’s target with the specified lemma or hypothesis,
closing the goal. We can often use <code>apply</code> in such situations, but <code>exact</code> communicates
our intentions better. In the example from Section 2.1, we could have used
<code>exact ha</code> instead of <code>apply ha</code>.</p>
<p><strong>assumption</strong></p>
<p>The <code>assumption</code> tactic finds a hypothesis from the local context that matches the
goal’s target and applies it to prove the goal. In the example from Section 2.1, we
could have used <code>assumption</code> instead of <code>apply ha</code></p>
<p><strong>cc</strong></p>
<p>The <code>cc</code> tactic implements an algorithm known as <a href="BackwardProofs/../bib.html#31">congruence closure</a> to derive new
equalities from those that are present in the goal. For example, if the goal contains <code>b = a</code> and
<code>f b ≠ f a</code> as hypotheses, the algorithm will derive <code>f b = f a</code> from <code>b = a</code> and discover a contradiction
with <code>f b ≠ f a</code>. The <code>cc</code> tactic is also suitable for more pedestrian work, such as proving
<code>hb : b ⊢ a ∨ b ∨ c</code> or discovering a contradiction among the goal’s hypotheses.</p>
<p>In addition, <code>cc</code> can be used to reason up to associativity (e.g., <code>(a + b) + c = a + (b + c)</code>) and
commutativity (e.g, <code>a + b = b + a</code>). This works for binary operations that are registered as
associative and commutative, such as <code>+</code> and <code>*</code> on arithmetic types, and <code>∪</code> and <code>∩</code> on sets. We will see
an example in Section 2.6.</p>
<p>At this point, you might wonder, “So what does <code>cc</code> do exactly?” Of course, you could look up the
<a href="BackwardProofs/../bib.html#31">reference</a> given above to the scientific paper that describes its underlying algorithm, or even
read the source code. But this might not be the most efficient use of your time. In truth, even expert
users of proof assistants do not fully understand the behavior of the tactics they use daily. The
most successful users adopt a relaxed, sporty attitude, trying tactics in sequence and studying the
emerging subgoals, if any, to see if they are on the right path.</p>
<p>As you keep on using <code>cc</code> and other tactics, you will develop some intuition about what kinds of
goal they work well on. This is one of the many reasons why interactive theorem proving can only be
learned by doing. Often, you will not understand exactly what Lean does—why a tactic succeeds, or
fails. Theorem proving can be very frustrating at times. The advice printed in large, friendly
letters on the cover of <em>The Hitchhiker’s Guide to the Galaxy</em> applies here: DON'T PANIC.</p>
<p><strong>sorry</strong></p>
<p>The <code>sorry</code> proof command we encountered in <a href="BackwardProofs/../Basics/TheoremStatements.lean.html">Theorem Statements</a>
is also available as a tactic. It “proves” the current goal without actually proving it. This is
normally used as a placeholder for a proof that is not yet available or an exercise left to the reader.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre><div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Mathlib.Tactic.Basic
<span class="kn">import</span> BackwardProofs.BasicTactics</span></span></pre>
<h2 id="reasoning-about-connectives-and-quantifiers"><a class="header" href="#reasoning-about-connectives-and-quantifiers">Reasoning about Connectives and Quantifiers</a></h2>
<p>Before we learn to reason about natural numbers, lists, or other data types, we
must first learn to reason about the logical connectives and quantifiers of Lean’s
logic. Let us start with a simple example: commutativity of conjunction (<code>∧</code>).</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>and_swap</var><b>: </b><span>∀ (a b : Prop), a ∧ b → b ∧ a</span></span></div></blockquote></div></small></div><span class="nv">and_swap</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">) :
</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">∧</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">∧</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a <span class="bp">∧</span> b <span class="bp">→</span> b <span class="bp">∧</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk1"><span class="alectryon-token"><span class="k">intro</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hab</var><b>: </b><span>a ∧ b</span></span></div></blockquote></div></small></div><span class="nv">hab</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b <span class="bp">∧</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk2"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>And.intro</var><b>: </b><span>∀ {a b : Prop}, a → b → a ∧ b</span></span></div></blockquote></div></small></div>And.intro</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">left</span></span><div class="goal-conclusion">b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ConnectivesAndQuantifiers-lean-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><label class="goal-separator" for="ConnectivesAndQuantifiers-lean-chk3"><hr><span class="goal-name">right</span></label><div class="goal-conclusion">a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk4"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>And.right</var><b>: </b><span>∀ {a b : Prop}, a ∧ b → b</span></span></div></blockquote></div></small></div>And.right</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">left.self</span></span><div class="goal-conclusion"><span class="bp">?</span>left.a <span class="bp">∧</span> b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ConnectivesAndQuantifiers-lean-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><label class="goal-separator" for="ConnectivesAndQuantifiers-lean-chk5"><hr><span class="goal-name">left.a</span></label><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="ConnectivesAndQuantifiers-lean-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><label class="goal-separator" for="ConnectivesAndQuantifiers-lean-chk6"><hr><span class="goal-name">right</span></label><div class="goal-conclusion">a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk7"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hab</var><b>: </b><span>a ∧ b</span></span></div></blockquote></div></small></div><span class="nv">hab</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">right</span></span><div class="goal-conclusion">a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk8"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>And.left</var><b>: </b><span>∀ {a b : Prop}, a ∧ b → a</span></span></div></blockquote></div></small></div>And.left</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">right.self</span></span><div class="goal-conclusion">a <span class="bp">∧</span> <span class="bp">?</span>right.b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ConnectivesAndQuantifiers-lean-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><label class="goal-separator" for="ConnectivesAndQuantifiers-lean-chk9"><hr><span class="goal-name">right.b</span></label><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chka"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hab</var><b>: </b><span>a ∧ b</span></span></div></blockquote></div></small></div><span class="nv">hab</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>At this point, we recommend that you move the cursor over each line in the above example to see the
sequence of proof states. By putting the cursor over each bubble at the end of the line, you can see
the effect of the command on that line. At the end of the last line Lean simply reports “goals
accomplished 🎉” meaning that no subgoals remain to be proved.</p>
<p>The proof is a typical <code>intro–apply–exact</code> mixture. It uses the lemmas</p>
<pre><code>And.intro : ?a → ?b → ?a ∧ ?b
And.left : ?a ∧ ?b → ?a
And.right : ?a ∧ ?b → ?b
</code></pre>
<p>where the question marks (?) indicate variables that can be instantiated—for example, by matching
the goal’s target against the conclusion of a lemma.</p>
<p>The three lemmas above are the introduction rule and the two elimination
rules associated with conjunction. An introduction rule for a symbol (e.g., <code>∧</code>) is
a lemma whose conclusion contains that symbol. Dually, an elimination rule has
the symbol in an assumption. In the above proof, we apply the introduction rule
associated with <code>∧</code> to prove the goal <code>⊢ b ∧ a</code>, and we apply the two elimination
rules to extract <code>b</code> and <code>a</code> from the hypothesis <code>a ∧ b</code>.</p>
<p>Question marks can also arise in goals. They indicate variables that can be
instantiated arbitrarily. In the middle of the proof above, right after the tactic
apply <code>And.right</code>, we have the goal</p>
<pre><code class="language-lean">a b : Prop, hab : a ∧ b ⊢ ?left.a ∧ b</code></pre>
<p>The tactic exact <code>hab</code> matches <code>?left.a</code> (in the target) with <code>a</code> (in <code>hab</code>). Because variables can
occur both in the hypothesis or lemma that is <code>apply</code>d and in the target, in general the procedure
used to instantiate variables to make two terms syntactically equal is called <em>unification</em>. Matching
is a special case of unification where one of the two terms contains no variables. In practice,
goals with variables are rare, so Lean’s unification usually amounts to matching.</p>
<pre><code>-- BUGBUG: no idea what most of that paragraph means.
</code></pre>
<p>In Lean, unification is performed up to computation. For example, the terms
<code>(λ x =&gt; ?left.a) a</code> and <code>b</code> can be unified by taking <code>?left.a := b</code>,
because <code>(λ x =&gt; b) a</code> and <code>b</code> are syntactically equal up to β-conversion.</p>
<p>The following is an alternative proof of the lemma <code>and_swap</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>and_swap2</var><b>: </b><span>∀ (a b : Prop), a ∧ b → b ∧ a</span></span></div></blockquote></div></small></div><span class="nv">and_swap2</span></span><span class="alectryon-token"> :
<span class="bp">∀</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">∧</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">∧</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chkb"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∀</span> (a b : <span class="kt">Prop</span>), a <span class="bp">∧</span> b <span class="bp">→</span> b <span class="bp">∧</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chkc"><span class="alectryon-token"><span class="k">intros</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hab</var><b>: </b><span>a ∧ b</span></span></div></blockquote></div></small></div><span class="nv">hab</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b <span class="bp">∧</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chkd"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>And.intro</var><b>: </b><span>∀ {a b : Prop}, a → b → a ∧ b</span></span></div></blockquote></div></small></div>And.intro</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">left</span></span><div class="goal-conclusion">b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ConnectivesAndQuantifiers-lean-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><label class="goal-separator" for="ConnectivesAndQuantifiers-lean-chke"><hr><span class="goal-name">right</span></label><div class="goal-conclusion">a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chkf"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">left</span></span><div class="goal-conclusion">b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk10"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>And.right</var><b>: </b><span>∀ {a b : Prop}, a ∧ b → b</span></span></div></blockquote></div></small></div>And.right</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hab</var><b>: </b><span>a ∧ b</span></span></div></blockquote></div></small></div><span class="nv">hab</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk11"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">right</span></span><div class="goal-conclusion">a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk12"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hab</var><span class="hyp-type"><b>: </b><span>a <span class="bp">∧</span> b</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">right</span></span><div class="goal-conclusion">a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk13"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>And.left</var><b>: </b><span>∀ {a b : Prop}, a ∧ b → a</span></span></div></blockquote></div></small></div>And.left</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hab</var><b>: </b><span>a ∧ b</span></span></div></blockquote></div></small></div><span class="nv">hab</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk14"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>The lemma is stated differently, with <code>a</code> and <code>b</code> as ∀-quantified variables instead of
parameters of the lemma. Logically, this is equivalent, but in the proof we must
then introduce <code>a</code> and <code>b</code> in addition to <code>hab</code>.</p>
<p>Another difference is the use of curly braces <code>{ }</code>. When we face two or more goals to prove, it is
generally good style to put each proof in its own block enclosed in curly braces. The <code>{ }</code> tactic
combinator focuses on the first subgoal; the tactic inside must prove it. In our example, the
<code>apply And.intro</code> tactic creates two subgoals, <code>⊢ b</code> and <code>⊢ a</code>.</p>
<p>A third difference is that we now apply, by juxtaposition, <code>And.right</code> and
<code>And.left</code> directly to the hypothesis <code>a ∧ b</code> to obtain <code>b</code> and <code>a</code>, respectively,
instead of waiting for the lemmas’ assumptions to emerge as new subgoals. This
is a small forward step in an otherwise backward proof. The same syntax is used
both to discharge (i.e., prove) a hypothesis and to instantiate a ∀-quantifier. One
benefit of this approach is that we avoid the potentially confusing <code>?left.a</code> variable.</p>
<p>The introduction and elimination rules for disjunction (∨) are as follows:</p>
<pre><code class="language-lean">Or.intro_left : ∀ b : Prop, ?a → ?a ∨ b
Or.intro_right : ∀ b : Prop, ?a → b ∨ ?a
Or.elim : ?a ∨ ?b → (?a → ?c) → (?b → ?c) → ?c</code></pre>
<p>--BUGBUG: what are all these question marks? Are they supposed to look like
unresolved metavariables?</p>
<p>The ∀-quantifiers in <code>Or.intro_left</code> and <code>Or.intro_right</code> can be instantiated
directly by applying the lemma name to the value we want to instantiate with,
via simple juxtaposition. Thus, <code>Or.intro_left false</code> corresponds to the lemma
<code>?a → ?a ∨ false</code>. This is the forward style.</p>
<p>Alternatively, we can invoke apply <code>Or.intro_left</code> on a goal of the form
<code>. . . ⊢ c ∨ d</code>. This instantiates the lemma with <code>?a := c</code> and <code>b := d</code>.
The new subgoal is <code>. . . ⊢ c</code>. This is the backward style.</p>
<p>Both <code>Or.intro_left</code> and <code>Or.intro_right</code> are unsafe: If you apply the wrong
one of the two, or either of them too early in a proof, you might end up with an
unprovable subgoal. This is easy to see if you consider the provable goal
<code>⊢ true ∨ false</code>: applying <code>Or.intro_right</code> yields the unprovable subgoal
<code>⊢ false</code>.</p>
<p>The <code>Or.elim</code> rule may seem counterintuitive at a first glance. In essence, it
states that if we have <code>a ∨ b</code>, then to prove an arbitrary <code>c</code>, it suffices to prove <code>c</code>
when <code>a</code> holds and when <code>b</code> holds. You can think of <code>(?a → ?c) → (?b → ?c) → ?c</code>
as a clever trick to express the concept of disjunction using only implication.</p>
<p>The introduction and elimination rules for equivalence (<code>↔</code>) are as follows:</p>
<pre><code class="language-lean">Iff.intro : (?a → ?b) → (?b → ?a) → (?a ↔ ?b)
Iff.mp : (?a ↔ ?b) → ?a → ?b
Iff.mpr : (?a ↔ ?b) → ?b → ?a</code></pre>
<p>The introduction and elimination rules for existential quantification (<code>∃</code>) are</p>
<pre><code class="language-lean">Exists.intro : ∀ w, (?p w → (∃x, ?p x))
Exists.elim : (∃ x, ?p x) → (∀a, ?p a → ?c) → ?c</code></pre>
<p>The introduction rule for <code>∃</code> can be used to instantiate an existential quantifier
with a witness. For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat_exists_double_iden</var><b>: </b><span>∃ n, double n = n</span></span></div></blockquote></div></small></div><span class="nv">nat_exists_double_iden</span></span><span class="alectryon-token"> :
  <span class="bp">∃</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℕ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℕ</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk15"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∃</span> n, double n <span class="bp">=</span> n</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk16"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Exists.intro</var><b>: </b><span>∀ {α : Type} {p : α → Prop} (w : α), p w → Exists p</span></span></div></blockquote></div></small></div>Exists.intro</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">0</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">double <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ConnectivesAndQuantifiers-lean-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="ConnectivesAndQuantifiers-lean-chk17"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Again, we instantiate a ∀-quantifier in a forward fashion: <code>Exists.intro 0</code> is the
lemma <code>?p 0 → (∃x, ?p x)</code>. The rule is unsafe: Choosing the wrong witness for <code>x</code>
will result in an unprovable goal. For example, if the goal is <code>⊢ ∃ n, n &gt; 5</code> and we
take 3 as the witness, we end up with the unprovable subgoal <code>⊢ 3 &gt; 5</code>.</p>
<p>The elimination rule for <code>∃</code> is reminiscent of <code>∨</code>. Indeed, a fruitful way to think
of a quantification <code>∃ n, ?p n</code> is as a possibly infinitary disjunction <code>?p 0 ∨ ?p 1 ∨ · · · </code>.
Similarly, <code>∀ n, ?p n</code> can be thought of as <code>?p 0 ∧ ?p 1 ∧ · · · </code>.
For truth (<code>true</code>), there is only an introduction rule:</p>
<pre><code class="language-lean">True.intro : true</code></pre>
<p>Truth holds no information whatsoever. If it appears as a hypothesis, it is completely useless, and
there is no elimination rule that will succeed at extracting any information from it. The <code>clear</code>
tactic, described in Section 2.8 below, can be used to remove such useless hypotheses.</p>
<p>Dually, for falsehood (<code>false</code>), there is only an elimination rule</p>
<pre><code class="language-lean">False.elim : false → ?a</code></pre>
<p>There is no way to prove falsehood, but if we somehow have it from somewhere
(e.g., from a hypothesis), then we can derive <code>?a</code>nything.</p>
<p>Negation (<code>not</code>) is defined in terms of implication and falsehood:
<code>¬ a</code> abbreviates <code>a → false</code>. Lean’s logic is classical, with support for the law of excluded
middle and proof by contradiction:</p>
<p>-- BUGBUG is this still true statemetn or is classical lean just one option now as per:
https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html?highlight=classical#classical-logic</p>
<pre><code class="language-lean">Classical.em : ∀ a : Prop, a ∨ ¬ a
Classical.byContradiction : (¬ ?a → false) → ?a</code></pre>
<p>Finally, implication (<code>→</code>) and universal quantification (<code>∀</code>) are the proverbial dogs
that did not bark. For both of them, the <code>intro</code> tactic is the introduction principle,
and application is the elimination principle. For example, given the lemmas
<code>hab : a → b</code> and <code>ha : a</code>, the juxtaposition <code>hab ha</code> is a lemma stating <code>b</code>.</p>
<p>For proving logic puzzles involving connectives and quantifiers, we advocate
a “mindless,” “video game” style of reasoning that relies mostly on basic tactics
such as <code>intro</code>(s) and <code>apply</code>. Here are some strategies that often work:</p>
<ul>
<li>
<p>If the goal’s target is an implication <code>P → Q</code>, invoke <code>intro hP</code> to move <code>P</code> into your
hypotheses: <code>. . ., hP : P ⊢ Q</code>.</p>
</li>
<li>
<p>If the goal’s target is a universal quantification <code>∀ x : σ, Q</code>, invoke <code>intro x</code> to move <code>x</code> into
the local context: <code>. . ., x : σ ⊢ Q</code>.</p>
</li>
<li>
<p>Look for a lemma or hypothesis whose conclusion has the same shape as the goal’s target (possibly
containing variables that can be matched), and apply it. For example, if the goal’s target is <code>Q</code>
and you have a lemma or hypothesis of the form <code>hPQ : P → Q</code>, try <code>apply hPQ</code>.</p>
</li>
<li>
<p>A negated goal <code>⊢ ¬ P</code> is syntactically equal to <code>⊢ P → false</code> up to computation, so you can
invoke <code>intro hP</code> to produce the subgoal <code>hP : P ⊢ false</code>. Expanding negation’s definition by
invoking <code>rw not_def</code> (described in Section 2.5) is often a good strategy.</p>
</li>
<li>
<p>Sometimes you can make progress by replacing the goal by <code>false</code>, by entering apply <code>False.elim</code>. As
next step, you would typically apply a lemma or hypothesis of the form <code>P → false</code> or <code>¬ P</code>.</p>
</li>
<li>
<p>When you face several choices (e.g., between <code>Or.intro_left</code> and <code>Or.intro_right</code>), remember which
choices you have made, and backtrack when you reach a dead end or have the impression you are not
making any progress.</p>
</li>
<li>
<p>If you suspect that you might have reached a dead end, check whether the goal actually is provable
under the given assumptions. Even if you started with a provable lemma statement, the current goal
might be unprovable (e.g., if you used unsafe rules such as <code>Or.intro_left</code>)</p>
</li>
</ul>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre><div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Mathlib.Tactic.Basic</span></span></pre>
<h2 id="reasoning-about-equality"><a class="header" href="#reasoning-about-equality">Reasoning about Equality</a></h2>
<p>Equality (<code>=</code>) is also a basic logical constant. It is characterized by the following
introduction and elimination rules:</p>
<pre><code class="language-lean">Eq.refl : ∀a, a = a
Eq.symm : ?a = ?b → ?b = ?a
Eq.trans : ?a = ?b → ?b = ?c → ?a = ?c
Eq.subst : ?a = ?b → ?p ?a → ?p ?b</code></pre>
<p>The first three lemmas are introduction rules specifying that <code>=</code> is an equivalence
relation. The fourth lemma is an elimination rule that allows us to replace equals
for equals in an arbitrary context, represented by the higher-order variable <code>?p</code>.</p>
<p>An example will show how this works. Below, we apply <code>Eq.subst</code> to rewrite
<code>f a b</code> to <code>f a' b</code>, using the equation <code>a = a'</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cong_fst_arg</var><b>: </b><span>∀ {α : Type} (a a' b : α) (f : α → α → α), a = a' → f a b = f a' b</span></span></div></blockquote></div></small></div><span class="nv">cong_fst_arg</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)
(</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a = a'</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a b <span class="bp">=</span> f a&#39; b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chk1"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Eq.subst</var><b>: </b><span>∀ {α : Type} {motive : α → Prop} {a b : α}, a = b → motive a → motive b</span></span></div></blockquote></div></small></div>Eq.subst</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a = a'</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: tactic <span class="bp">&#39;</span>apply&#39; failed, failed to unify
  <span class="bp">?</span>m.33 a&#39;
<span class="k">with</span>
  f a b <span class="bp">=</span> f a&#39; b
α : <span class="kt">Type</span>
a a&#39; b : α
f : α <span class="bp">→</span> α <span class="bp">→</span> α
ha : a <span class="bp">=</span> a&#39;
<span class="bp">⊢</span> f a b <span class="bp">=</span> f a&#39; b</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a b <span class="bp">=</span> f a&#39; b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span><span class="alectryon-token"></span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chk2"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> Eq.refl</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a b <span class="bp">=</span> f a&#39; b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="c1">-- BUGBUG doesn&#39;t work.</span></span></span></pre>
<p>The <code>Eq.subst</code> instance we use has <code>?a := a</code>, <code>?b := a'</code>, and <code>?p := (λ x, f a b = f x b)</code>:</p>
<pre><code class="language-lean">a = a' → (λx, f a b = f x b) a → (λx, f a b = f x b) a'</code></pre>
<p>In β-reduced form:</p>
<pre><code class="language-lean">a = a' → f a b = f a b → f a b = f a' b</code></pre>
<p>The lemma's first assumption matches the hypothesis <code>ha : a = a'</code>, which is passed as an argument in the
first apply invocation. The lemma's second assumption is a trivial equality that can be proved by
apply <code>Eq.refl</code> or <code>rfl</code>. The lemma's conclusion matches the goal’s target. Notice how a higher-order
variable (e.g., <code>?p</code>) can represent an arbitrary context (e.g., <code>f . . . b</code>) around a term (e.g.,
<code>a</code> or <code>a'</code>). This works because <code>apply</code> unifies up to computation, including β-conversion.</p>
<p>The <code>Eq.subst</code> lemma can be applied several times in sequence, as follows:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cong_two_args</var><b>: </b><span>∀ {α : Type} (a a' b b' : α) (f : α → α → α), a = a' → b = b' → f a b = f a' b'</span></span></div></blockquote></div></small></div><span class="nv">cong_two_args</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b&#39;</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)
  (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a = a'</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hb</var><b>: </b><span>b = b'</span></span></div></blockquote></div></small></div><span class="nv">hb</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b&#39;</span></span><span class="alectryon-token">) :
</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b&#39;</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chk3"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b, b'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>b <span class="bp">=</span> b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a b <span class="bp">=</span> f a&#39; b&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chk4"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Eq.subst</var><b>: </b><span>∀ {α : Type} {motive : α → Prop} {a b : α}, a = b → motive a → motive b</span></span></div></blockquote></div></small></div>Eq.subst</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a = a'</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: tactic <span class="bp">&#39;</span>apply&#39; failed, failed to unify
  <span class="bp">?</span>m.93 a&#39;
<span class="k">with</span>
  f a b <span class="bp">=</span> f a&#39; b&#39;
α : <span class="kt">Type</span>
a a&#39; b b&#39; : α
f : α <span class="bp">→</span> α <span class="bp">→</span> α
ha : a <span class="bp">=</span> a&#39;
hb : b <span class="bp">=</span> b&#39;
<span class="bp">⊢</span> f a b <span class="bp">=</span> f a&#39; b&#39;</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b, b'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>b <span class="bp">=</span> b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a b <span class="bp">=</span> f a&#39; b&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span><span class="alectryon-token"></span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chk5"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> Eq.subst hb
  </span><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> Eq.refl</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b, b'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>b <span class="bp">=</span> b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a b <span class="bp">=</span> f a&#39; b&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="c1">-- BUGBUG doesn&#39;t work.</span></span></span></pre>
<p>Since rewriting in this way is such a common operation, Lean provides a <code>rw</code> tactic
to achieve the same result. The tactic will also notice if <code>rfl</code> is applicable:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cong_two_args₂</var><b>: </b><span>∀ {α : Type} (a a' b b' : α) (f : α → α → α), a = a' → b = b' → f a b = f a' b'</span></span></div></blockquote></div></small></div><span class="nv">cong_two_args₂</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b&#39;</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)
  (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a = a'</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hb</var><b>: </b><span>b = b'</span></span></div></blockquote></div></small></div><span class="nv">hb</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b&#39;</span></span><span class="alectryon-token">) :
</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b&#39;</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chk6"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b, b'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>b <span class="bp">=</span> b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a b <span class="bp">=</span> f a&#39; b&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chk7"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b, b'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>b <span class="bp">=</span> b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a b <span class="bp">=</span> f a&#39; b&#39;</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chk8"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ha</var><b>: </b><span>a = a'</span></span></div></blockquote></div></small></div><span class="nv">ha</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b, b'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>b <span class="bp">=</span> b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a&#39; b <span class="bp">=</span> f a&#39; b&#39;</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chk9"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b, b'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>b <span class="bp">=</span> b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a&#39; b <span class="bp">=</span> f a&#39; b&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chka"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b, b'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>b <span class="bp">=</span> b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a&#39; b <span class="bp">=</span> f a&#39; b&#39;</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chkb"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hb</var><b>: </b><span>b = b'</span></span></div></blockquote></div></small></div><span class="nv">hb</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a', b, b'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br><span><var>ha</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br><span><var>hb</var><span class="hyp-type"><b>: </b><span>b <span class="bp">=</span> b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a&#39; b&#39; <span class="bp">=</span> f a&#39; b&#39;</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Equality-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="Equality-lean-chkc"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>A note on parsing: Equality binds more tightly than the logical connectives.
Thus, <code>a = a' ∧ b = b'</code> should be read as (a = a') ∧ (b = b').</p>
<div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Mathlib.Tactic.Basic</span></span></pre>
<h2 id="rewriting-tactics"><a class="header" href="#rewriting-tactics">Rewriting Tactics</a></h2>
<p>The rewriting tactic <code>rw</code> and its relative <code>simp</code> replace equals for equals. Unlike <code>cc</code>,
they use equations as left-to-right rewrite rules. By default, they operate on the
goal’s target, but they can also be used to rewrite hypotheses specified using the
<code>at</code> keyword:</p>
<div class="table-wrapper"><table><thead><tr><th>at</th><th>description</th></tr></thead><tbody>
<tr><td><code>at ⊢</code></td><td>applies to the target (the default)</td></tr>
<tr><td><code>at h₁ . . . hₙ</code></td><td>applies to the specified hypotheses</td></tr>
<tr><td><code>at *</code></td><td>applies to all hypotheses and the target</td></tr>
</tbody></table>
</div>
<p><strong>rw</strong></p>
<pre><code>rw lemma-or-constant [at position]
</code></pre>
<p>The rw tactic applies a single equation as a left-to-right rewrite rule. It searches for the first
subterm that matches the rule’s left-hand side; once found, all occurrences of that subterm are
replaced by the right-hand side of the rule. If the rule contains variables, these are instantiated
as necessary. To apply a lemma as a right-to-left rewrite rule, put a short left arrow (<code>←</code>) in front
of the lemma’s name.</p>
<p>Given the lemma <code>l : ∀x, g x = f x</code> and the goal <code>⊢ h (f a) (g b) (g c)</code>, the
tactic <code>rw l</code> produces the subgoal <code>⊢ h (f a) (f b) (g c)</code>, whereas <code>rw ←l</code> produces the subgoal
<code>⊢ h (g a) (g b) (g c)</code>.</p>
<p>Instead of a lemma, we can also specify the name of a constant. This will attempt to
use one of the constant’s defining equations as rewrite rules. For technical reasons, this does not
work with not (<code>¬</code>), and we must use <code>rw not_def</code> instead.</p>
<p><strong>simp</strong></p>
<pre><code>simp [at position]
</code></pre>
<p>The simp tactic applies a standard set of rewrite rules, called the <em>simp</em> set, exhaustively. The simp
set can be extended by putting the <code>@[simp]</code> attribute on lemmas. Unlike <code>rw</code>, <code>simp</code> can rewrite terms
containing bound variables (e.g., occurrences of <code>x</code> in the body of <code>λx =&gt; . . .</code>, <code>∀x, . . .</code>, or
<code>∃x, . . .</code>).</p>
<pre><code>simp [lemma-or-constant₁, . . . , lemma-or-constantₙ] [at position]
</code></pre>
<p>For the above <code>simp</code> variant, the specified lemmas are temporarily added to the simp set. In the
lemma list, an asterisk (<code>*</code>) can be use to represent all hypotheses. The minus sign (<code>-</code>) in front
of a lemma name temporarily removes the lemma from the simp set. A powerful incantation that both
simplifies the hypotheses and uses the result to simplify the goal’s target is <code>simp [*] at *</code>.</p>
<p>Given the <code>lemma l : ∀x, g x = f x</code> and the goal <code>⊢ h (f a) (g b) (g c)</code>, the tactic <code>simp [l]</code>
produces the subgoal <code>⊢ h (f a) (f b) (f c)</code>, where both <code>g b</code> and <code>g c</code> have been rewritten. Instead of a
lemma, we can also specify the name of a constant. This temporarily adds the constant’s defining
equations to the simp set.</p>
<p>To find out what simp does, you can enable tracing via the command</p>
<pre><code class="language-lean">set_option trace.simplify.rewrite true              -- this was lean3
set_option trace.Meta.Tactic.simp.rewrite true      -- BUGBUG: is this the correct lean4 option?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Mathlib.Tactic.Basic
<span class="kn">import</span> Mathlib.Tactic.Cases
<span class="kn">import</span> Basics.FunctionDefinitions</span></span></pre>
<h2 id="proofs-by-mathematical-induction"><a class="header" href="#proofs-by-mathematical-induction">Proofs by Mathematical Induction</a></h2>
<p>The <code>induction'</code> tactic performs structural induction on an inductive type. <em>Structural induction</em>
simply means that the induction follows the structure of the inductive type. For natural numbers
constructed from <code>Nat.zero</code> and <code>Nat.succ</code>, structural induction corresponds to standard mathematical
induction: To prove <code>p n</code>, it suffices to prove <code>p 0</code> and <code>∀k, p k → p (k + 1)</code>. Equipped with <code>induction'</code>,
we can reason about the addition and multiplication operations we defined by recursion in
<a href="BackwardProofs/../Basics/FunctionDefinitions.lean.html">Function Definitions</a>. Addition is defined by recursion on its
second argument. We will prove two lemmas, <code>add_zero</code> and <code>add_succ</code>, that give us alternative equations
that recurse on the first argument. We start with <code>add_zero</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add_zero</var><b>: </b><span>∀ (n : ℕ), add 0 n = n</span></span></div></blockquote></div></small></div><span class="nv">add_zero</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℕ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℕ</span><span class="alectryon-token">) :
</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">add <span class="mi">0</span> n <span class="bp">=</span> n</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk1"><span class="alectryon-token"><span class="k">induction&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"> n ih</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">add <span class="mi">0</span> Nat.zero <span class="bp">=</span> Nat.zero</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Induction-lean-chk2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add <span class="mi">0</span> n <span class="bp">=</span> n</span></span></span><br></div><label class="goal-separator" for="Induction-lean-chk2"><hr><span class="goal-name">succ</span></label><div class="goal-conclusion">add <span class="mi">0</span> (Nat.succ n) <span class="bp">=</span> Nat.succ n</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk3"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">add <span class="mi">0</span> Nat.zero <span class="bp">=</span> Nat.zero</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk4"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk5"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add <span class="mi">0</span> n <span class="bp">=</span> n</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">add <span class="mi">0</span> (Nat.succ n) <span class="bp">=</span> Nat.succ n</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk6"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add <span class="mi">0</span> n <span class="bp">=</span> n</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">add <span class="mi">0</span> (Nat.succ n) <span class="bp">=</span> Nat.succ n</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk7"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>add 0 n = n</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk8"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>The first <code>{ }</code> encloses the base case <code>⊢ add 0 0 = 0</code>. The second block corresponds
to the induction step</p>
<pre><code class="language-lean">n : N, ih : add 0 n = n ` add 0 (Nat.succ n) = (Nat.succ n)</code></pre>
<p>The local variable <code>n</code> in the induction step should not be confused with the <code>n</code> in
the lemma statement. Like mathematicians, <code>induction’</code> tries to reuse variable
names that are no longer needed. The name <code>ih</code> for the induction hypothesis, in
the induction step, is also generated by the <code>induction’</code> tactic.</p>
<p>We can keep on proving lemmas by structural induction:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add_succ</var><b>: </b><span>∀ (m n : ℕ), add (Nat.succ m) n = Nat.succ (add m n)</span></span></div></blockquote></div></small></div><span class="nv">add_succ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℕ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℕ</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>Nat.succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ</var><b>: </b><span>ℕ → ℕ</span></span></div></blockquote></div></small></div>Nat.succ</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk9"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">add (Nat.succ m) n <span class="bp">=</span> Nat.succ (add m n)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chka"><span class="alectryon-token"><span class="k">induction&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"> n ih</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">add (Nat.succ m) Nat.zero <span class="bp">=</span> Nat.succ (add m Nat.zero)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Induction-lean-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add (Nat.succ m) n <span class="bp">=</span> Nat.succ (add m n)</span></span></span><br></div><label class="goal-separator" for="Induction-lean-chkb"><hr><span class="goal-name">succ</span></label><div class="goal-conclusion">add (Nat.succ m) (Nat.succ n) <span class="bp">=</span> Nat.succ (add m (Nat.succ n))</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chkc"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">add (Nat.succ m) Nat.zero <span class="bp">=</span> Nat.succ (add m Nat.zero)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chkd"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chke"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add (Nat.succ m) n <span class="bp">=</span> Nat.succ (add m n)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">add (Nat.succ m) (Nat.succ n) <span class="bp">=</span> Nat.succ (add m (Nat.succ n))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chkf"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add (Nat.succ m) n <span class="bp">=</span> Nat.succ (add m n)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">add (Nat.succ m) (Nat.succ n) <span class="bp">=</span> Nat.succ (add m (Nat.succ n))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk10"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>add (Nat.succ m) n = Nat.succ (add m n)</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk11"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add_comm</var><b>: </b><span>∀ (m n : ℕ), add m n = add n m</span></span></div></blockquote></div></small></div><span class="nv">add_comm</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℕ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℕ</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk12"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">add m n <span class="bp">=</span> add n m</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk13"><span class="alectryon-token"><span class="k">induction&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"> n ih</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">add m Nat.zero <span class="bp">=</span> add Nat.zero m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Induction-lean-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add m n <span class="bp">=</span> add n m</span></span></span><br></div><label class="goal-separator" for="Induction-lean-chk14"><hr><span class="goal-name">succ</span></label><div class="goal-conclusion">add m (Nat.succ n) <span class="bp">=</span> add (Nat.succ n) m</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk15"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">add m Nat.zero <span class="bp">=</span> add Nat.zero m</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk16"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add_zero</var><b>: </b><span>∀ (n : ℕ), add 0 n = n</span></span></div></blockquote></div></small></div>add_zero</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk17"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add m n <span class="bp">=</span> add n m</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">add m (Nat.succ n) <span class="bp">=</span> add (Nat.succ n) m</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk18"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add m n <span class="bp">=</span> add n m</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">add m (Nat.succ n) <span class="bp">=</span> add (Nat.succ n) m</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk19"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add_succ</var><b>: </b><span>∀ (m n : ℕ), add (Nat.succ m) n = Nat.succ (add m n)</span></span></div></blockquote></div></small></div>add_succ</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>add m n = add n m</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk1a"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add_assoc</var><b>: </b><span>∀ (l m n : ℕ), add (add l m) n = add l (add m n)</span></span></div></blockquote></div></small></div><span class="nv">add_assoc</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℕ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℕ</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk1b"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">add (add l m) n <span class="bp">=</span> add l (add m n)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk1c"><span class="alectryon-token"><span class="k">induction&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"> n ih</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">add (add l m) Nat.zero <span class="bp">=</span> add l (add m Nat.zero)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Induction-lean-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add (add l m) n <span class="bp">=</span> add l (add m n)</span></span></span><br></div><label class="goal-separator" for="Induction-lean-chk1d"><hr><span class="goal-name">succ</span></label><div class="goal-conclusion">add (add l m) (Nat.succ n) <span class="bp">=</span> add l (add m (Nat.succ n))</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk1e"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">add (add l m) Nat.zero <span class="bp">=</span> add l (add m Nat.zero)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk1f"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk20"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add (add l m) n <span class="bp">=</span> add l (add m n)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">add (add l m) (Nat.succ n) <span class="bp">=</span> add l (add m (Nat.succ n))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk21"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>add (add l m) n <span class="bp">=</span> add l (add m n)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">add (add l m) (Nat.succ n) <span class="bp">=</span> add l (add m (Nat.succ n))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk22"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>add (add l m) n = add l (add m n)</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk23"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Once we have proved that a binary operator is commutative and associative, it
is a good idea to let Lean’s automation, notably <code>cc</code>, know about this. The following
commands achieve this for add:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">@</span>[</span><span class="alectryon-token"><span class="kd">instance</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add.is_commutative</var><b>: </b><span>sorryAx (Sort u_1) true</span></span></div></blockquote></div></small></div><span class="nv">add.is_commutative</span></span><span class="alectryon-token"> : </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk24"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>is_commutative</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div>is_commutative</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unknown identifier <span class="bp">&#39;</span>is_commutative&#39;</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var> N add</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div> N add</span><span class="alectryon-token"> :=
</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>{ comm := add_comm }</var><b>: </b><span>sorryAx (Sort u_1) true</span></span></div></blockquote></div></small></div>{ comm := add_comm }</span><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="kd">instance</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add.is_associative</var><b>: </b><span>sorryAx (Sort u_1) true</span></span></div></blockquote></div></small></div><span class="nv">add.is_associative</span></span><span class="alectryon-token"> : </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk25"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>is_associative</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div>is_associative</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unknown identifier <span class="bp">&#39;</span>is_associative&#39;</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var> N add</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div> N add</span><span class="alectryon-token"> :=
</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>{ assoc := add_assoc }</var><b>: </b><span>sorryAx (Sort u_1) true</span></span></div></blockquote></div></small></div>{ assoc := add_assoc }</span><span class="alectryon-token">

<span class="c1">-- BUGBUG: &#39;is_commutative&#39; and &#39;cc&#39; are still missing from mathlib...</span></span></span></pre>
<p>(The @[instance] mechanism will be explained in Chapter 4.) The following example uses the <code>cc</code> tactic
to reason up to associativity and commutativity of add:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">lemma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul_add</var><b>: </b><span>∀ (l m n : ℕ), mul l (add m n) = add (mul l m) (mul l n)</span></span></div></blockquote></div></small></div><span class="nv">mul_add</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ℕ</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>ℕ</span><span class="alectryon-token">) :
</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk26"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul l (add m n) <span class="bp">=</span> add (mul l m) (mul l n)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk27"><span class="alectryon-token"><span class="k">induction&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>ℕ</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"> n ih</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">mul l (add m Nat.zero) <span class="bp">=</span> add (mul l m) (mul l Nat.zero)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Induction-lean-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>mul l (add m n) <span class="bp">=</span> add (mul l m) (mul l n)</span></span></span><br></div><label class="goal-separator" for="Induction-lean-chk28"><hr><span class="goal-name">succ</span></label><div class="goal-conclusion">mul l (add m (Nat.succ n)) <span class="bp">=</span> add (mul l m) (mul l (Nat.succ n))</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk29"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">zero</span></span><div class="goal-conclusion">mul l (add m Nat.zero) <span class="bp">=</span> add (mul l m) (mul l Nat.zero)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk2a"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk2b"><span class="alectryon-token">}</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>mul l (add m n) <span class="bp">=</span> add (mul l m) (mul l n)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">mul l (add m (Nat.succ n)) <span class="bp">=</span> add (mul l m) (mul l (Nat.succ n))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk2c"><span class="alectryon-token">{</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unsolved goals
case succ
l m n : ℕ
ih : mul l (add m n) <span class="bp">=</span> add (mul l m) (mul l n)
<span class="bp">⊢</span> add l (add (mul l m) (mul l n)) <span class="bp">=</span> add (mul l m) (add l (mul l n))</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>mul l (add m n) <span class="bp">=</span> add (mul l m) (mul l n)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">mul l (add m (Nat.succ n)) <span class="bp">=</span> add (mul l m) (mul l (Nat.succ n))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk2d"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mul</var><b>: </b><span>ℕ → ℕ → ℕ</span></span></div></blockquote></div></small></div>mul</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>mul l (add m n) = add (mul l m) (mul l n)</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unsolved goals
case succ
l m n : ℕ
ih : mul l (add m n) <span class="bp">=</span> add (mul l m) (mul l n)
<span class="bp">⊢</span> add l (add (mul l m) (mul l n)) <span class="bp">=</span> add (mul l m) (add l (mul l n))</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>mul l (add m n) <span class="bp">=</span> add (mul l m) (mul l n)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">add l (add (mul l m) (mul l n)) <span class="bp">=</span> add (mul l m) (add l (mul l n))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Induction-lean-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="Induction-lean-chk2e"><span class="alectryon-token">cc</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unsolved goals
case succ
l m n : ℕ
ih : mul l (add m n) <span class="bp">=</span> add (mul l m) (mul l n)
<span class="bp">⊢</span> add l (add (mul l m) (mul l n)) <span class="bp">=</span> add (mul l m) (add l (mul l n))</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l, m, n</var><span class="hyp-type"><b>: </b><span>ℕ</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>mul l (add m n) <span class="bp">=</span> add (mul l m) (mul l n)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">succ</span></span><div class="goal-conclusion">add l (add (mul l m) (mul l n)) <span class="bp">=</span> add (mul l m) (add l (mul l n))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> }    <span class="c1">-- BUGBUG: &#39;cc&#39; is still missing from mathlib...</span></span></span></pre>
<p>Here are a few hints on how to carry out proofs by induction:</p>
<ul>
<li>
<p>It is usually beneficial to perform induction following the structure of the definition of one of
the functions appearing in the goal. In particular, if a function is defined by recursion on its
<em>n</em> th argument, it usually makes sense to perform the induction on that argument.</p>
</li>
<li>
<p>If the base case of an induction is difficult, this is often a sign that the wrong variable was
chosen or that some lemmas should be proved first.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Mathlib.Tactic.Basic</span></span></pre>
<h2 id="induction-tactic"><a class="header" href="#induction-tactic">Induction Tactic</a></h2>
<p><strong>induction'</strong></p>
<pre><code>induction’ term [with name₁ . . . nameₙ]
</code></pre>
<p>The <code>induction’</code> tactic performs structural induction on the specified term. This gives rise to as
many subgoals as there are constructors in the definition of the term’s type. Induction hypotheses
are available as hypotheses in the subgoals corresponding to recursive constructors (e.g., <code>Nat.succ</code>
or <code>List.cons</code>). The optional names <code>name₁, . . . , nameₙ</code> are used for any emerging variables or
hypotheses. Note that the standard Lean tactic for structural induction is called <code>induction</code>. The
primed variant is provided by <code>mathlib</code>. It is more user-friendly and is the only one we will use.</p>
<div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Mathlib.Tactic.Basic</span></span></pre>
<h2 id="cleanup-tactics"><a class="header" href="#cleanup-tactics">Cleanup Tactics</a></h2>
<p>The following tactics help us clean up the goal by allowing us to give more meaningful names to
variables or hypotheses or to remove useless hypotheses. We did not need them so far, but they can
be helpful during proof exploration.</p>
<p><strong>rename</strong></p>
<pre><code>rename variable-or-hypothesis new-name
</code></pre>
<p>The rename tactic changes the name of a variable or hypothesis.</p>
<p><strong>clear</strong></p>
<pre><code>clear variable-or-hypothesis₁ . . . variable-or-hypothesisₙ
</code></pre>
<p>The clear tactic removes the specified variables and hypotheses, as long as they
are not used anywhere else in the goal.</p>
<div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Mathlib.Tactic.Basic</span></span></pre>
<h2 id="summary-of-new-lean-constructs-1"><a class="header" href="#summary-of-new-lean-constructs-1">Summary of New Lean Constructs</a></h2>
<p><strong>Commands</strong></p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td><code>set_option</code></td><td>changes or activates tracing, syntax output, etc.</td></tr>
</tbody></table>
</div>
<p><strong>Attribute</strong></p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td><code>@[simp]</code></td><td>adds a lemma to the simp set</td></tr>
</tbody></table>
</div>
<p><strong>Proof Commands</strong></p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td><code>by</code></td><td>applies a single tactic</td></tr>
</tbody></table>
</div>
<p><strong>Tactics</strong></p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>apply</td><td>matches the goal’s target with the lemma’s conclusion and replaces the goal with the lemma’s hypotheses</td></tr>
<tr><td>assumption</td><td>proves the goal using a hypothesis</td></tr>
<tr><td>cc</td><td>propagates equalities up to to associativity and commutativity</td></tr>
<tr><td>clear</td><td>removes a variable or hypothesis from the goal</td></tr>
<tr><td>exact</td><td>proves the goal using the specified lemma</td></tr>
<tr><td>induction’</td><td>performs structural induction on a variable of an inductive type</td></tr>
<tr><td>intro(s)</td><td>moves ∀-quantified variables into the goal’s hypotheses</td></tr>
<tr><td>refl</td><td>proves l = r where l and r are equal up to computation</td></tr>
<tr><td>rename</td><td>renames a variable or hypothesis</td></tr>
<tr><td>rewrite</td><td>applies the given rewrite rule once</td></tr>
<tr><td>simp</td><td>applies a set of preregistered rewrite rules exhaustively</td></tr>
<tr><td>sorry</td><td>stands for a missing proof or definition</td></tr>
</tbody></table>
</div>
<p><strong>Tactic Combinator</strong></p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td><code>{ . . . }</code></td><td>focuses on the first subgoal; needs to prove that goal</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="bibliography"><a class="header" href="#bibliography">Bibliography</a></h1>
<h3 id="1"><a class="header" href="#1">1</a></h3>
<p>J. Avigad, L. de Moura, and S. Kong. Theorem Proving in Lean: Release 3.20.0.
2020. https://leanprover.github.io/theorem_proving_in_lean/.</p>
<h3 id="2"><a class="header" href="#2">2</a></h3>
<p>J. Avigad, L. de Moura, and J. Roesch. Programming in Lean. 2016.
https://leanprover.github.io/programming_in_lean/.</p>
<h3 id="3"><a class="header" href="#3">3</a></h3>
<p>J. Avigad, G. Ebner, and S. Ullrich. The Lean Reference Manual: Release 3.3.0.
2018. https://leanprover.github.io/reference/.</p>
<h3 id="4"><a class="header" href="#4">4</a></h3>
<p>A. Baanen. A Lean tactic for normalising ring expressions with exponents
(short paper). In N. Peltier and V. Sofronie-Stokkermans, editors, IJCAR 2020,
volume 12167 of Lecture Notes in Computer Science, pages 21–27. Springer,
2020. https://lean-forward.github.io/ring_exp/paper.pdf.</p>
<h3 id="5"><a class="header" href="#5">5</a></h3>
<p>H. P. Barendregt, W. Dekkers, and R. Statman. Lambda Calculus with Types.
Perspectives in logic. Cambridge University Press, 2013.</p>
<h3 id="6"><a class="header" href="#6">6</a></h3>
<p>M. Carneiro. The type theory of Lean. MSc thesis, Carnegie Mellon
University, 2019. https://github.com/digama0/lean-typetheory/releases/download/v1.0/main.pdf.</p>
<h3 id="7"><a class="header" href="#7">7</a></h3>
<p>G. Ebner, S. Ullrich, J. Roesch, J. Avigad, and L. de Moura. A metaprogramming
framework for formal verification. PACMPL, 1(ICFP):34:1–34:29, 2017.
https://leanprover.github.io/papers/tactic.pdf.</p>
<h3 id="8"><a class="header" href="#8">8</a></h3>
<p>G. Gonthier. Formal proof—the Four-Color Theorem. Notices AMS,
55(11):1382–1393, 2008.
https://www.ams.org/notices/200811/tx081101382p.pdf.</p>
<h3 id="9"><a class="header" href="#9">9</a></h3>
<p>G. Gonthier, A. Asperti, J. Avigad, Y. Bertot, C. Cohen, F. Garillot, S. L. Roux,
A. Mahboubi, R. O’Connor, S. O. Biha, I. Pasca, L. Rideau, A. Solovyev, E. Tassi,
and L. Théry. A machine-checked proof of the Odd Order Theorem. In
S. Blazy, C. Paulin-Mohring, and D. Pichardie, editors, ITP 2013, volume 7998
of Lecture Notes in Computer Science, pages 163–179. Springer, 2013.
https://hal.inria.fr/hal-00816699/document.</p>
<h3 id="10-k-gopinathan-and-i-sergey-certifying-certainty-and-uncertainty-in"><a class="header" href="#10-k-gopinathan-and-i-sergey-certifying-certainty-and-uncertainty-in">10 K. Gopinathan and I. Sergey. Certifying certainty and uncertainty in</a></h3>
<p>approximate membership query structures. In S. Lahiri and C. Wang, editors,
CAV 2020, Lecture Notes in Computer Science. Springer, 2020.
https://ilyasergey.net/papers/ceramist-draft.pdf.</p>
<h3 id="11"><a class="header" href="#11">11</a></h3>
<p>R. Gu, Z. Shao, H. Chen, X. N. Wu, J. Kim, V. Sjöberg, and D. Costanzo.
CertiKOS: An extensible architecture for building certified concurrent OS
kernels. In K. Keeton and T. Roscoe, editors, OSDI 2016, pages 653–669.
USENIX Association, 2016. https:
//www.usenix.org/system/files/conference/osdi16/osdi16-gu.pdf.</p>
<h3 id="12"><a class="header" href="#12">12</a></h3>
<p>T. C. Hales, M. Adams, G. Bauer, D. T. Dang, J. Harrison, T. L. Hoang, C. Kaliszyk,
V. Magron, S. McLaughlin, T. T. Nguyen, T. Q. Nguyen, T. Nipkow, S. Obua,
J. Pleso, J. Rute, A. Solovyev, A. H. T. Ta, T. N. Tran, D. T. Trieu, J. Urban, K. K. Vu,
and R. Zumkeller. A formal proof of the Kepler conjecture. CoRR,
abs/1501.02155, 2015. http://arxiv.org/abs/1501.02155.</p>
<h3 id="13"><a class="header" href="#13">13</a></h3>
<p>J. Harrison. Formal verification at Intel. In LICS 2003, pages 45–54. IEEE
Computer Society, 2003.
https://ieeexplore.ieee.org/document/1210044.</p>
<h3 id="14"><a class="header" href="#14">14</a></h3>
<p>J. Harrison, J. Urban, and F. Wiedijk. History of interactive theorem proving.
In J. H. Siekmann, editor, Computational Logic, volume 9 of Handbook of the
History of Logic, pages 135–214. Elsevier, 2014.
https://www.cl.cam.ac.uk/~jrh13/papers/joerg.pdf.</p>
<h3 id="15"><a class="header" href="#15">15</a></h3>
<p>J. R. Hindley. The principal type-scheme of an object in combinatory logic.
Trans. Amer. Math. Soc., 146:29–60, 1969. https://www.jstor.org/stable/
pdf/1995158.pdf?casa_token=zeSppXjXzUsAAAAA:
fzvl6NKVjcL0iVXjyrMSbh_bq0sxtY4iPeoX5NMC6FvlOdMDxYG1paIiqrc6P2Q7UTaT46PVHByMTWrpox4SKwOhbcxjLIm-FxWRDx-FtdyWwHa0ueG.</p>
<h3 id="16"><a class="header" href="#16">16</a></h3>
<p>G. Klein, J. Andronick, K. Elphinstone, G. Heiser, D. Cock, P. Derrin,
D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell, H. Tuch, and
S. Winwood. seL4: Formal verification of an operating-system kernel.
Commun. ACM, 53(6):107–115, 2010. https://www.researchgate.net/
profile/Gernot_Heiser/publication/220910193_SeL4_Formal_
verification_of_an_OS_kernel/links/09e4150f00292a0329000000/SeL4-
Formal-verification-of-an-OS-kernel.pdf.</p>
<h3 id="17"><a class="header" href="#17">17</a></h3>
<p>D. E. Knuth. The TEXbook. Addison-Wesley, 1986.
http://www.ctex.org/documents/shredder/src/texbook.pdf.</p>
<h3 id="18"><a class="header" href="#18">18</a></h3>
<p>R. Kumar, M. O. Myreen, M. Norrish, and S. Owens. CakeML: A verified
implementation of ML. In S. Jagannathan and P. Sewell, editors, POPL 2014,
pages 179–192. ACM, 2014. https://cakeml.org/popl14.pdf.</p>
<h3 id="19"><a class="header" href="#19">19</a></h3>
<p>X. Leroy. A formally verified compiler back-end. J. Automated Reasoning,
43(4):363–446, 2009. https://arxiv.org/pdf/0902.2137.pdf.</p>
<h3 id="20"><a class="header" href="#20">20</a></h3>
<p>R. Y. Lewis. A formal proof of Hensel’s lemma over the p-adic integers. In
A. Mahboubi and M. O. Myreen, editors, CPP 2019, pages 15–26. ACM, 2019.
https://arxiv.org/pdf/1909.11342.pdf.</p>
<h3 id="21"><a class="header" href="#21">21</a></h3>
<p>J. Limperg. A novice-friendly induction tactic for Lean. In C. Hritcu and
A. Popescu, editors, CPP ’21, pages 199–211. ACM, 2021.
https://arxiv.org/pdf/2012.08990.pdf.</p>
<h3 id="22"><a class="header" href="#22">22</a></h3>
<p>M. Lipovaca. Learn You a Haskell for Great Good!: A Beginner’s Guide. No
Starch Press, 1st edition, 2011. http://learnyouahaskell.com/.</p>
<h3 id="23"><a class="header" href="#23">23</a></h3>
<p>A. Lochbihler. Verifying a compiler for Java threads. In A. D. Gordon, editor,
ESOP 2010, volume 6012 of Lecture Notes in Computer Science, pages
427–447. Springer, 2010. https:
//link.springer.com/content/pdf/10.1007/978-3-642-11957-6_23.pdf.</p>
<h3 id="24"><a class="header" href="#24">24</a></h3>
<p>The mathlib Community. The Lean mathematical library. In J. Blanchette
and C. Hrit,cu, editors, CPP 2020, pages 367–381. ACM, 2020.
https://arxiv.org/pdf/1910.09336.pdf.</p>
<h3 id="25"><a class="header" href="#25">25</a></h3>
<p>R. Milner. A theory of type polymorphism in programming. J. Comput. Syst.
Sci., 17(3):348–375, 1978.
https://www.sciencedirect.com/science/article/pii/0022000078900144/pdf?md5=cdcf7cdb7cfd2e1e4237f4f779ca0df7&amp;pid=1-s2.0-0022000078900144-main.pdf&amp;_valck=1.</p>
<h3 id="26"><a class="header" href="#26">26</a></h3>
<p>R. Nederpelt and H. Geuvers. Type Theory and Formal Proof: An Introduction.
Cambridge University Press, 2014.</p>
<h3 id="27"><a class="header" href="#27">27</a></h3>
<p>T. Nipkow and G. Klein. Concrete Semantics: With Isabelle/HOL. Springer,
2014. http://www.concrete-semantics.org/concrete-semantics.pdf.</p>
<h3 id="28"><a class="header" href="#28">28</a></h3>
<p>B. O’Sullivan, D. Stewart, and J. Goerzen. Real World Haskell. O’Reilly, 2008.
http://book.realworldhaskell.org/read/.</p>
<h3 id="29"><a class="header" href="#29">29</a></h3>
<p>A. J. Perlis. Epigrams on programming. SIGPLAN Notices, 17(9):7–13, 1982.
https://dl.acm.org/doi/pdf/10.1145/947955.1083808?asa_token=Z_grmOD_yAYAAAAA:dvMu7thQc-8XmGJCZ1ARQ24_XB1qel3M1jYUmBPAKfuBaZrryxmKiKValMrwpunJ0dv9vhr2kDvMxA.</p>
<h3 id="30"><a class="header" href="#30">30</a></h3>
<p>B. C. Pierce. Types and Programming Languages. MIT Press, 2002.</p>
<h3 id="31"><a class="header" href="#31">31</a></h3>
<p>F. van Raamsdonk. Logical Verification: Course Notes. 2011.
https://www.cs.vu.nl/~jbe248/lv2017/notes.pdf.</p>
<h3 id="32"><a class="header" href="#32">32</a></h3>
<p>D. M. Russino. A mechanically checked proof of correctness of the AMD K5
floating point square root microcode. Formal Methods in System Design,
14(1):75–125, 1999. https://link.springer.com/content/pdf/10.1023/A:
1008669628911.pdf.</p>
<h3 id="33"><a class="header" href="#33">33</a></h3>
<p>D. Selsam and L. de Moura. Congruence closure in intensional type theory.
In N. Olivetti and A. Tiwari, editors, IJCAR 2016, volume 9706 of Lecture Notes
in Computer Science, pages 99–115. Springer, 2016.
https://arxiv.org/pdf/1701.04391.pdf.</p>
<h3 id="34"><a class="header" href="#34">34</a></h3>
<p>C. Watt. Mechanising and verifying the WebAssembly specification. In
J. Andronick and A. P. Felty, editors, CPP 2018, pages 53–65. ACM, 2018.
https://www.cl.cam.ac.uk/~caw77/papers/mechanising-and-verifyingthe-webassembly-specification.pd</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>

        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script src="alectryon.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
