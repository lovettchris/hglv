<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rule Induction - The Hitchhiker’s Guide to Logical Verification</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../alectryon.css">
        <link rel="stylesheet" href="../pygments.css">
        <link rel="stylesheet" href="../custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../cover.html">Cover</a></li><li class="chapter-item affix "><a href="../preface.html">Preface</a></li><li class="chapter-item "><a href="../Basics/Definitions.lean.html"><strong aria-hidden="true">1.</strong> Definitions and Statements</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../Basics/TypesAndTerms.lean.html"><strong aria-hidden="true">1.1.</strong> Types and Terms</a></li><li class="chapter-item "><a href="../Basics/TypeDefinitions.lean.html"><strong aria-hidden="true">1.2.</strong> Type Definitions</a></li><li class="chapter-item "><a href="../Basics/FunctionDefinitions.lean.html"><strong aria-hidden="true">1.3.</strong> Function Definitions</a></li><li class="chapter-item "><a href="../Basics/TheoremStatements.lean.html"><strong aria-hidden="true">1.4.</strong> Theorem Statements</a></li><li class="chapter-item "><a href="../Basics/Summary.html"><strong aria-hidden="true">1.5.</strong> Summary of New Lean Constructs</a></li></ol></li><li class="chapter-item "><a href="../BackwardProofs.lean.html"><strong aria-hidden="true">2.</strong> Backward Proofs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../BackwardProofs/TacticMode.lean.html"><strong aria-hidden="true">2.1.</strong> Tactic Mode</a></li><li class="chapter-item "><a href="../BackwardProofs/BasicTactics.lean.html"><strong aria-hidden="true">2.2.</strong> Basic Tactics</a></li><li class="chapter-item "><a href="../BackwardProofs/ConnectivesAndQuantifiers.lean.html"><strong aria-hidden="true">2.3.</strong> Reasoning about Connectives and Quantifiers</a></li><li class="chapter-item "><a href="../BackwardProofs/Equality.lean.html"><strong aria-hidden="true">2.4.</strong> Reasoning about Equality</a></li><li class="chapter-item "><a href="../BackwardProofs/RewritingTactics.lean.html"><strong aria-hidden="true">2.5.</strong> Rewriting Tactics</a></li><li class="chapter-item "><a href="../BackwardProofs/Induction.lean.html"><strong aria-hidden="true">2.6.</strong> Proofs by Mathematical Induction</a></li><li class="chapter-item "><a href="../BackwardProofs/InductionTactic.lean.html"><strong aria-hidden="true">2.7.</strong> Induction Tactic</a></li><li class="chapter-item "><a href="../BackwardProofs/CleanupTactics.lean.html"><strong aria-hidden="true">2.8.</strong> Cleanup Tactics</a></li><li class="chapter-item "><a href="../BackwardProofs/Summary.lean.html"><strong aria-hidden="true">2.9.</strong> Summary of New Lean Constructs</a></li></ol></li><li class="chapter-item "><a href="../ForwardProofs.lean.html"><strong aria-hidden="true">3.</strong> Forward Proofs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ForwardProofs/StructuredProofs.lean.html"><strong aria-hidden="true">3.1.</strong> Structured Proofs</a></li><li class="chapter-item "><a href="../ForwardProofs/StructuredConstructs.lean.html"><strong aria-hidden="true">3.2.</strong> Structured Constructs</a></li><li class="chapter-item "><a href="../ForwardProofs/Connectives.lean.html"><strong aria-hidden="true">3.3.</strong> Forward Reasoning about Connectives and Quantifiers</a></li><li class="chapter-item "><a href="../ForwardProofs/CalculationProofs.lean.html"><strong aria-hidden="true">3.4.</strong> Calculation Proofs</a></li><li class="chapter-item "><a href="../ForwardProofs/ForwardTactics.lean.html"><strong aria-hidden="true">3.5.</strong> Forward Reasoning with Tactics</a></li><li class="chapter-item "><a href="../ForwardProofs/DependentTypes.lean.html"><strong aria-hidden="true">3.6.</strong> Dependent Types</a></li><li class="chapter-item "><a href="../ForwardProofs/CurryHoward.lean.html"><strong aria-hidden="true">3.7.</strong> The Curry–Howard Correspondence</a></li><li class="chapter-item "><a href="../ForwardProofs/InductionPatterns.lean.html"><strong aria-hidden="true">3.8.</strong> Induction by Pattern Matching</a></li><li class="chapter-item "><a href="../ForwardProofs/Summary.lean.html"><strong aria-hidden="true">3.9.</strong> Summary of New Lean Constructs</a></li></ol></li><li class="chapter-item "><a href="../FunctionalProgramming.lean.html"><strong aria-hidden="true">4.</strong> Functional Programming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../FunctionalProgramming/InductiveTypes.lean.html"><strong aria-hidden="true">4.1.</strong> Inductive Types</a></li><li class="chapter-item "><a href="../FunctionalProgramming/StructuralInduction.lean.html"><strong aria-hidden="true">4.2.</strong> Structural Induction</a></li><li class="chapter-item "><a href="../FunctionalProgramming/StructuralRecursion.lean.html"><strong aria-hidden="true">4.3.</strong> Structural Recursion</a></li><li class="chapter-item "><a href="../FunctionalProgramming/PatternMatching.lean.html"><strong aria-hidden="true">4.4.</strong> Pattern Matching Expressions</a></li><li class="chapter-item "><a href="../FunctionalProgramming/Structures.lean.html"><strong aria-hidden="true">4.5.</strong> Structures</a></li><li class="chapter-item "><a href="../FunctionalProgramming/TypeClasses.lean.html"><strong aria-hidden="true">4.6.</strong> Type Classes</a></li><li class="chapter-item "><a href="../FunctionalProgramming/Lists.lean.html"><strong aria-hidden="true">4.7.</strong> Lists</a></li><li class="chapter-item "><a href="../FunctionalProgramming/BinaryTrees.lean.html"><strong aria-hidden="true">4.8.</strong> Binary Trees</a></li><li class="chapter-item "><a href="../FunctionalProgramming/CaseDistinction.lean.html"><strong aria-hidden="true">4.9.</strong> Case Distinction and Induction Tactics</a></li><li class="chapter-item "><a href="../FunctionalProgramming/DependentInductiveTypes.lean.html"><strong aria-hidden="true">4.10.</strong> Dependent Inductive Types</a></li><li class="chapter-item "><a href="../FunctionalProgramming/Summary.lean.html"><strong aria-hidden="true">4.11.</strong> Summary of New Lean Constructs</a></li></ol></li><li class="chapter-item expanded "><a href="../InductivePredicates.lean.html"><strong aria-hidden="true">5.</strong> Inductive Predicates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../InductivePredicates/IntroductoryExamples.lean.html"><strong aria-hidden="true">5.1.</strong> Introductory Examples</a></li><li class="chapter-item "><a href="../InductivePredicates/LogicalSymbols.html"><strong aria-hidden="true">5.2.</strong> Logical Symbols</a></li><li class="chapter-item expanded "><a href="../InductivePredicates/RuleInduction.html" class="active"><strong aria-hidden="true">5.3.</strong> Rule Induction</a></li></ol></li><li class="chapter-item "><a href="../bib.html"><strong aria-hidden="true">6.</strong> Bibliography</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hitchhiker’s Guide to Logical Verification</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/leanprover/HitchikersGuide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>import Mathlib.Tactic.Basic
import Mathlib.Init.Data.Nat.Basic
import InductivePredicates.IntroductoryExamples
/-!</p>
<h2 id="rule-induction"><a class="header" href="#rule-induction">Rule Induction</a></h2>
<p>In the same way that we can perform an induction on a term of inductive type, we can perform an
induction on a proof of an inductive predicate. For example, given the goal <code>h : Even n ⊢ p n</code>, we
can invoke <code>induction’ h</code> and get two subgoals, for <code>Even.zero</code> and <code>Even.add_two</code>. This is called
<em>induction on the structure of the derivation of <code>h</code></em> or simply <em>rule induction</em>, because the induction is
on the predicate’s introduction rules (i.e., the constructors of the proof term).</p>
<p>There are two ways to look at rule induction: the “least-predicate-such-that view” and the “PAT
view.” To understand the least-predicate-such-that view, recall that an inductive definition
introduces a symbol as the least (i.e., the most false) predicate satisfying the introduction rules.
Accordingly, <code>Even</code> is the least predicate <code>q</code> such that the properties <code>q 0</code> and <code>∀k, q k → q (k + 2)</code>
hold. Therefore, if we can show that <code>p 0</code> and <code>∀k, p k → p (k + 2)</code> hold for some predicate <code>p</code>, then <code>p</code>
is either <code>Even</code> itself or greater than (i.e., more true than) <code>Even</code>. As a result, <code>Even n</code> implies <code>p n</code>,
which is exactly what we need to prove the goal <code>h : Even n ⊢ p n</code>.</p>
<p>The least-predicate-such-that view gives a nice intuitive account of rule induction that can be used
in informal arguments, such as the following proof that <code>Even n</code> implies <code>n % 2 = 0</code> for all <code>n</code>:</p>
<ul>
<li>The proof is by rule induction on the hypothesis <code>Even n</code>.</li>
<li>Case <code>Even.zero</code>: We must show <code>0 % 2 = 0</code>. This follows by computation.</li>
<li>Case <code>Even.add_two k</code>: The induction hypothesis is <code>k % 2 = 0</code>. We must
show <code>(k + 2) % 2 = 0</code>. This follows by basic arithmetic reasoning. <span class="qed"></span></li>
</ul>
<p>The Lean proof has the same structure:
-/
lemma mod_two_eq_zero_of_even (n : ℕ) (h : Even n) :
n % 2 = 0 := by
induction' h
case zero =&gt; rfl
case add_two k hk ih =&gt; simp [ih]
/-!
The PAT principle gives us another fruitful way to look at rule induction. The
key idea is that rule induction on <code>h</code> in a goal such as <code>h : Even n ⊢ P[h]</code> is perfectly
analogous to structural induction on a value of a dependent inductive type such
as <code>Vec α n</code> (Section 4.10). Writing <code>Pᵤ[ ]</code> for the variant of <code>P[ ]</code> where <code>n</code> is replaced
by some term <code>u</code>, we get the subgoals</p>
<pre><code class="language-lean">⊢ P₀[Even.zero : Even 0]
k : ℕ, hk : Even k, ih : Pₖ[hk] ⊢ Pₖ₊₂[Even.add_two k hk : Even (k + 2)]</code></pre>
<p>These are precisely the subgoals produced by <code>induction’ h</code> with <code>k hk ih</code>.</p>
<p>Regardless of the inductive predicate <code>q</code>, the procedure to compute the subgoals is always the same:</p>
<ol>
<li>Replace <code>h</code> in <code>P[h]</code> with each possible introduction rule applied to fresh variables (e.g.,
<code>Even.add_two k hk</code>), massaging <code>P[ ]</code> to make it type-correct. This yields as many subgoals as
there are introduction rules.</li>
<li>Add these new variables (e.g., <code>k</code>, <code>hk</code>) to the local context.</li>
<li>Add induction hypotheses for all new hypotheses that assert <code>q</code> . . .</li>
</ol>
<p>Notice the presence of <code>hk : Even k</code> among the hypotheses above. It was absent
in the least-predicate-such-that view and is not essential because it can always
be recovered by strengthening <code>P</code> to be of the form <code>Even n ∧ · · ·</code>.</p>
<p>In nearly all practical cases, <code>h</code> will not occur in <code>P[h]</code>. We can then simply write</p>
<pre><code>⊢ P₀   k : ℕ, hk : Even k, ih : Pₖ ⊢ Pₖ₊₂
</code></pre>
<p>In rare cases, <code>h</code> will occur in <code>P[h]</code>. Proofs may appear as subterms in arbitrary
terms, as we saw when we tried to extract the head of a list in
<a href="../FunctionalProgramming/Lists.lean.html">Section 4.7</a></p>
<p>When the argument to <code>Even</code> in <code>h</code> is not a variable, performing an induction will
destroy its structure. Fortunately, <code>induction’</code> (with a prime) notices this situation
and preserves the information in a hypothesis called <code>index_eq</code>. Thus, given the
goal <code>h : Even (2 * n + 1) ⊢ false</code>, invoking <code>induction’ h</code> with <code>k hk ih</code> produces
the induction step</p>
<pre><code>k : ℕ, h : Even k, n : ℕ, index_eq : k + 1 = 2 * n, ih : ∀n, ¬ k = 2 * n + 1
⊢ false
</code></pre>
<p>for <code>Even.add_two</code>. The trivial base case <code>¬ Even 1</code> is eliminated automatically by
basic constructor reasoning.</p>
<p>The hypothesis <code>index_eq</code> records the equality between <code>Even</code>’s argument in the
initial goal (i.e., <code>2 * n + 1</code>) and <code>Even</code>’s argument in the <code>Even.add_two</code> rule
(i.e., <code>k + 2</code>). Notice that the equation is simplified by subtracting 1 from both sides. To
continue the proof, we need to instantiate <code>n</code> in the induction hypothesis with <code>n - 1</code>.
Here is the complete proof:
-/
lemma not_even_two_mul_add_one (n : ℕ) :
¬ Even (2 * n + 1) := by
intro h
induction' h
apply ih (n - 1)
cases' n
case zero =&gt; { simp_arith }
case succ =&gt; {
simp [Nat.succ_eq_add_one] at *
simp_arith }</p>
<p>--BUGBUG error: index in target's type is not a variable (consider using the <code>cases</code> tactic instead)
--BUGBUG the book used tactic linarith, but it doesn't seem to be defined
/-!</p>
<p>We use the lemma <code>Nat.succ_eq_add_one</code> to rewrite terms of the form <code>Nat.succ n</code> to <code>n + 1</code> and the
<code>simp_arith</code> tactic to perform simple arithmetic reasoning. The lemma is very useful when we face a
mixture of <code>Nat.succ</code> and addition.</p>
<p>The reflexive transitive closure <code>Star r</code> is similar to <code>Even</code>. Given a goal
<code>h : Star r x y ⊢ P</code>, rule induction on <code>h</code> produces the following subgoals, where <code>Pa,b</code> denotes
the variant of <code>P</code> where <code>x</code> and <code>y</code> are replaced by <code>a</code> and <code>b</code>, respectively:</p>
<pre><code class="language-lean">a b : α, hab : r t u ⊢ Pa,b
a : α ⊢ Pa,a
a b c : α, hab : star r a b, hbc : star r b c, ihab : Pa,b, ihbc : Pb,c ⊢ Pa,c</code></pre>
<p>Notice these three subgoals match the introduction rules for <code>Start</code>, namely <code>base</code>, <code>refl</code> and <code>trans</code>.</p>
<p>-- BUGBUG: book has Pa,b written using subscripts, but unicode doesn't seem to define those
so is the book using a custom font for that?</p>
<p>This is where the “assistant” aspect of “proof assistant” comes into play. One of
the key properties of <code>Star</code> is idempotence—applying <code>Star</code> to <code>Star r</code> has no effect.
This can be proved as follows in Lean, using rule induction for the → direction of
the equivalence:
-/
lemma star_star_iff_star {α : Type} (r : α → α → Prop)
(a b : α) : Star (Star r) a b ↔ Star r a b := by
apply Iff.intro
{ intro h
induction' h
case base a b hab =&gt; exact hab
case refl a =&gt; apply Star.refl
case trans a b c hab hbc ihab ihbc =&gt;
apply Star.trans a b
exact ihab
exact ihbc }
{ intro h
apply Star.base
exact h }
/-!
We use the <code>case</code> tactic both to document which cases we are focusing on and to give intuitive names
to the emerging variables. It is easy to get lost in goals containing long, automatically generated
names. The cleanup tactics introduced in <a href="../BackwardProofs/CleanupTactics.lean.html">Section 2.8</a> can
also be a great help when facing large goals.</p>
<p>We can state the idempotence property more standardly in terms of equality
instead of as an equivalence:</p>
<p>-/
lemma star_star_eq_star {α : Type}
(r : α → α → Prop) : Star (Star r) = Star r := by
apply funext
intro a
apply funext
intro b
apply propext
apply star_star_iff_star</p>
<p>/-!
The proof requires two lemmas that are available because Lean’s logic is classical:</p>
<pre><code>funext : (∀x, ?f x = ?g x) → ?f = ?g
propext : (?a ↔ ?b) → ?a = ?b
</code></pre>
<p>Functional extensionality (<code>funext</code>) states that if two functions yield equal results for all
inputs, then the two functions must be equal. Propositional extensionality (<code>propext</code>) states that
equivalence of propositions coincides with equality. In these phrases, extensionality means
something like “what you see is what you get.” These properties may seem obvious, and yet there
exist proof assistants built on weaker, intuitionistic logics in which the properties do not
generally hold.</p>
<p>In <a href="../FunctionalProgramming/PatternMatching.lean.html">Chapter 4</a>, we saw a diagram depicting the
interpretation of bool and Prop side by side. The diagram suggested the existence of an infinite
number of propositions, but we now know that there are exactly two propositions: false and true.
Moreover, the latter admits any number of proofs. Here is a revised diagram (with only five proofs
shown):</p>
<p><img src="diagram.svg" alt="diagram" /></p>
<p>We register the lemma <code>star_star_eq_star</code> as a <code>simp</code> rule using:
-/
attribute [simp] star_star_eq_star
/-!
because viewed as a left-to-right rewrite rule, it genuinely replaces a complex term by a simpler
term. It is hard to imagine a situation where we would not want <code>simp</code> to rewrite <code>Star (Star . . .)</code>
to <code>Star . . .</code>.</p>
<p>For rule induction, we normally use the <code>induction'</code> tactic. For subtle logical
reasons that will become clearer in Chapter 11, rule induction by pattern matching
is generally not possible.
-/</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../InductivePredicates/LogicalSymbols.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../bib.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../InductivePredicates/LogicalSymbols.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../bib.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" charset="utf-8"></script>
        <script src="../mark.min.js" charset="utf-8"></script>
        <script src="../searcher.js" charset="utf-8"></script>

        <script src="../clipboard.min.js" charset="utf-8"></script>
        <script src="../highlight.js" charset="utf-8"></script>
        <script src="../book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script src="../alectryonjs.js"></script>


    </body>
</html>
